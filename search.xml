<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[HTML5基础介绍]]></title>
      <url>http://jimmypeng.cn/2016/09/22/HTML5base/</url>
      <content type="html"><![CDATA[<p><img src="http://7xpbws.com1.z0.glb.clouddn.com/html5logo.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/800" alt=""></p>
<blockquote>
<p>HTML5 肯定不是多了一些标签就完事了<br>HTML5 根酷炫没什么关系，更多的职责是功能，而不是外观</p>
</blockquote>
<hr>
<h3 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h3><h4 id="WEB技术阶段"><a href="#WEB技术阶段" class="headerlink" title="WEB技术阶段"></a>WEB技术阶段</h4><ol>
<li>Web 1.0 内容为主，主要流行HTML和CSS</li>
<li>Web 2.0 动态网页，流行AJAX/JavaScript/DOM</li>
<li>HTML5 时代，WEB开发回归富客户端</li>
</ol>
<h4 id="什么是HTML5"><a href="#什么是HTML5" class="headerlink" title="什么是HTML5"></a>什么是HTML5</h4><ul>
<li>是HTML的超集，不仅仅是HTML，更多的是JavaScript API和CSS的提升，</li>
<li>构建 Web 应用程序整体解决方案</li>
</ul>
<blockquote>
<p>API的概念就是我们编程时所依赖的东西的总称</p>
</blockquote>
<a id="more"></a>
<h4 id="什么是Web-Application"><a href="#什么是Web-Application" class="headerlink" title="什么是Web Application"></a>什么是Web Application</h4><ul>
<li>HTML5 前身，由WHATWG组织提出</li>
<li>推出的目的主要是提高Web应用程序的功能</li>
<li>2007年提交到W3C组织，成了现在我们看到的HTML5</li>
</ul>
<h4 id="HTML5应用场景"><a href="#HTML5应用场景" class="headerlink" title="HTML5应用场景"></a>HTML5应用场景</h4><ul>
<li>极具表现力的网页<ul>
<li>案例非常多</li>
</ul>
</li>
<li>网页应用程序<ul>
<li>PC端：iCloud、百度脑图、Office 365···</li>
<li>APP端：淘宝、京东、美团···</li>
<li>WeChat端：淘宝、京东、美团···</li>
</ul>
</li>
<li>混合式本地应用<ul>
<li>PC端：网易云音乐、有道词典···</li>
<li>APP端：淘宝、京东、美团···</li>
</ul>
</li>
<li>简单的游戏</li>
</ul>
<h4 id="H5新特性概要"><a href="#H5新特性概要" class="headerlink" title="H5新特性概要"></a>H5新特性概要</h4><h5 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h5><ul>
<li>标签<ul>
<li>更语义化标签</li>
</ul>
</li>
<li>智能表单<ul>
<li>新的表单类型，如：email,url,number</li>
<li>新增表单功能属性，如：autocomplete，autofocus</li>
<li>虚拟键盘适配，通过表单的类型决定移动端弹出的键盘类型</li>
</ul>
</li>
<li>网页多媒体，我们可以在网页中直接通过原生方式播放视频音频<ul>
<li>音频</li>
<li>视频</li>
<li>字幕</li>
</ul>
</li>
<li>属性，语义化属性<ul>
<li>链接关系描述</li>
<li>结构数据标记</li>
<li>ARIA</li>
<li>自定义属性</li>
</ul>
</li>
<li>Canvas，提供网页绘图的可能，后面在Canvas课程会专门去学习<ul>
<li>2D 绘图</li>
<li>3D (WebGL)</li>
</ul>
</li>
<li>SVG</li>
</ul>
<h5 id="JavaScript-API"><a href="#JavaScript-API" class="headerlink" title="JavaScript API"></a>JavaScript API</h5><ul>
<li>核心平台提升，JS在DOM和BOM两个方向上都新增了很多api，便于开发应用程序<ul>
<li>新的选择器</li>
<li>Element.classList</li>
<li>访问历史API</li>
<li>全屏API</li>
</ul>
</li>
<li>网页存储，提供网页中操作客户端本地存储的API<ul>
<li>Application Cache</li>
<li>localStorage</li>
<li>sessionStorage</li>
<li>WebSQL</li>
<li>IndexedDB</li>
</ul>
</li>
<li>设备信息访问，JS可以访问硬件的一些信息，我们在移动手机APP的课程中再看<ul>
<li>网络状态</li>
<li>硬件访问</li>
<li>设备方向</li>
<li>地理围栏</li>
</ul>
</li>
<li>拖放操作<ul>
<li>网页内拖放</li>
<li>桌面拖入</li>
</ul>
</li>
<li>文件<ul>
<li>文件系统API</li>
<li>FileReader</li>
</ul>
</li>
<li>网络访问<ul>
<li>XMLHttpRequest</li>
<li>fetch</li>
<li>WebSocket</li>
</ul>
</li>
<li>多线程</li>
<li>桌面通知，</li>
</ul>
<h5 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h5><ul>
<li>后面详细讨论</li>
</ul>
<hr>
<h3 id="HTML5-骨架"><a href="#HTML5-骨架" class="headerlink" title="HTML5 骨架"></a>HTML5 骨架</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- HTML5的DOCTYPE声明做了最大简化 --&gt;</span></div><div class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></div><div class="line">    <span class="comment">&lt;!-- 在标准的HTML5骨架中charset是直接在meta中设置charset --&gt;</span></div><div class="line">    <span class="comment">&lt;!-- 字符编码的设置一定是在head中的第一行 --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>页面标题<span class="tag">&lt;/<span class="name">title</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">    </div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure>
<ul>
<li>HTML5的DOCTYPE声明做了最大简化</li>
<li>在标准的HTML5骨架中charset是直接在meta中设置charset</li>
<li>字符编码的设置一定是在head中的第一行，再晚就来不及了</li>
</ul>
<h3 id="语义化标签"><a href="#语义化标签" class="headerlink" title="语义化标签"></a>语义化标签</h3><h4 id="什么是语义化标签"><a href="#什么是语义化标签" class="headerlink" title="什么是语义化标签"></a>什么是语义化标签</h4><ul>
<li>HTML5中制定了一系列语义化标签：<ul>
<li>section：独立的内容节块，一般包含标题和内容</li>
<li>article：一种特殊的section，定义文档中的具体的文章内容</li>
<li>nav：页面导航的链接组</li>
<li>aside：标签用来装载非正文的内容，此标签中的文字权重低</li>
<li>header：定义文档的页眉，不仅仅是文档的页头可以使用header，一个独立块的头部也应该使用header</li>
<li>footer：定义section或document的页脚</li>
</ul>
</li>
<li>我们应该根据内容的性质决定使用特定的标签</li>
<li><p>h1一定只能出现一个，不是HTML的约定，页面中最重要的内容</p>
</li>
<li><p>time标签专门用于时间，</p>
<ul>
<li>datetime应该是一个标准时间格式，</li>
<li>pubdate指的是当前时间为article的发布时间 </li>
</ul>
</li>
<li><p>在H5中，主体结构标签默认和DIV都是相同的块级效果，</p>
</li>
<li>但是DIV没有语义，而以上标签有特定语义</li>
</ul>
<h4 id="为什么要有语义化标签"><a href="#为什么要有语义化标签" class="headerlink" title="为什么要有语义化标签"></a>为什么要有语义化标签</h4><ul>
<li>能够便于开发者阅读和写出更优雅的代码，代码如诗</li>
<li>同时让浏览器或是网络爬虫可以很好地解析，从而更好分析其中的内容</li>
<li>使用语义化标签会具有更好地搜索引擎优化</li>
</ul>
<h5 id="切记"><a href="#切记" class="headerlink" title="切记"></a>切记</h5><ul>
<li>HTML的职责是描述一块内容是什么（或其意义）</li>
<li>而不是它长的什么样子，它的外观应该由CSS来决定。</li>
</ul>
<hr>
<h3 id="智能表单"><a href="#智能表单" class="headerlink" title="智能表单"></a>智能表单</h3><h4 id="新的表单类型"><a href="#新的表单类型" class="headerlink" title="新的表单类型"></a>新的表单类型</h4><ul>
<li>email - 限定输入内容为邮箱地址，表单提交时会校验格式</li>
<li>url - 限定输入内容为URL，表单提交时会校验格式</li>
<li>number - 限定输入内容为数字，表单提交时会校验格式</li>
<li>range - 数值范围选择器</li>
<li>Date Pickers - 日期时间选择器<ul>
<li>样式不能修改，移动端用的比较多，因为移动端显示的是系统的时间或日期选择器</li>
<li>date - 选取日、月、年</li>
<li>month - 选取月、年</li>
<li>week - 选取周和年</li>
<li>time - 选取时间（小时和分钟）</li>
<li>datetime - 选取时间、日、月、年，浏览器兼容性不好，效果等同于datetime-local</li>
<li>datetime-local - 选取本地时间、日、月、年</li>
</ul>
</li>
<li>search - 搜索域，语义化，表示定义搜索框</li>
</ul>
<h4 id="新的表单属性"><a href="#新的表单属性" class="headerlink" title="新的表单属性"></a>新的表单属性</h4><ul>
<li><p>form</p>
<ul>
<li>autocomplete 设置整个表单是否开启自动完成 on|off</li>
<li>novalidate 设置H5的表单校验是否工作 true 不工作  不加该属性代表校验</li>
</ul>
</li>
<li><p>input:</p>
<ul>
<li>autocomplete 单独设置每个文本框的自动完成</li>
<li>autofocus 设置当前文本域页面加载完了过后自动得到焦点</li>
<li>form 属性是让表单外的表单元素也可以跟随表单一起提交</li>
<li>form overrides<ul>
<li>formaction 在submit上重写表单的特定属性，当点击当前submit时会以当前值使用</li>
<li>formenctype,</li>
<li>formmethod,</li>
<li>formnovalidate,</li>
<li>formtarget</li>
</ul>
</li>
<li>list 作用就是指定当前文本框的自动完成列表的数据 datalist 在界面上是看不见的，只是用于定义数据列表的</li>
<li>min / max / step<ul>
<li>min max 限制值的范围，但是不会再输入时限制，提交时校验，</li>
<li>step设置的是每次加减的增量</li>
<li>主要使用在number range datepicker上</li>
</ul>
</li>
<li>multiple<ul>
<li>文本域的多选</li>
</ul>
</li>
<li>pattern<ul>
<li>设置文本框的匹配格式（正则）</li>
</ul>
</li>
<li>placeholder<ul>
<li>文本框占位符</li>
</ul>
</li>
<li>required<ul>
<li>限制当前input为必须的</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="虚拟键盘适配"><a href="#虚拟键盘适配" class="headerlink" title="虚拟键盘适配"></a>虚拟键盘适配</h4><ul>
<li>在移动端中，我们可以通过不同的表单类型控制弹出的键盘类型</li>
</ul>
<h4 id="关于什么时候使用H5的新特性，能不能使用新特性的问题"><a href="#关于什么时候使用H5的新特性，能不能使用新特性的问题" class="headerlink" title="关于什么时候使用H5的新特性，能不能使用新特性的问题"></a>关于什么时候使用H5的新特性，能不能使用新特性的问题</h4><ul>
<li>无伤大雅的地方直接用<ul>
<li>比如一个文本框，加上placeholder就具备占位文本提示功能，浏览器不支持也不会报错，那就可以直接使用</li>
<li>再比如<code>&lt;input type=&quot;email&quot;&gt;</code>，如果浏览器不支持，默认会显示文本框，那也可以直接用。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="网页多媒体"><a href="#网页多媒体" class="headerlink" title="网页多媒体"></a>网页多媒体</h3><h4 id="音频"><a href="#音频" class="headerlink" title="音频"></a>音频</h4><h4 id="视频"><a href="#视频" class="headerlink" title="视频"></a>视频</h4><h4 id="多媒体标签属性"><a href="#多媒体标签属性" class="headerlink" title="多媒体标签属性"></a>多媒体标签属性</h4><h4 id="自定义播放器外观"><a href="#自定义播放器外观" class="headerlink" title="自定义播放器外观"></a>自定义播放器外观</h4><h4 id="全屏-API"><a href="#全屏-API" class="headerlink" title="全屏 API"></a>全屏 API</h4><h4 id="SVG"><a href="#SVG" class="headerlink" title="SVG *"></a>SVG *</h4><hr>
<h2 id="JS-基础-API"><a href="#JS-基础-API" class="headerlink" title="JS 基础 API"></a>JS 基础 API</h2><h3 id="新选择器"><a href="#新选择器" class="headerlink" title="新选择器"></a>新选择器</h3><h3 id="Element-classList"><a href="#Element-classList" class="headerlink" title="Element.classList"></a>Element.classList</h3><h3 id="自定义属性-DATA"><a href="#自定义属性-DATA" class="headerlink" title="自定义属性 DATA-* !"></a>自定义属性 DATA-* !</h3><h3 id="访问历史API"><a href="#访问历史API" class="headerlink" title="访问历史API *"></a>访问历史API *</h3>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Runtime基本介绍]]></title>
      <url>http://jimmypeng.cn/2016/09/22/Runtimebase/</url>
      <content type="html"><![CDATA[<p><code>Objective-C</code>语言是一门动态语言，它将很多静态语言在编译和链接时期做的事放到了运行时来处理。这种动态语言的优势在于：我们写代码时更具灵活性，如我们可以把消息转发给我们想要的对象，或者随意交换一个方法的实现等。</p>
<p>这种特性意味着<code>Objective-C</code>不仅需要一个编译器，还需要一个运行时系统来执行编译的代码。对于<code>Objective-C</code>来说，这个运行时系统就像一个操作系统一样：它让所有的工作可以正常的运行。这个运行时系统即Objc <code>Runtime</code>。Objc <code>Runtime</code>其实是一个<code>Runtime</code>库，它基本上是用C和汇编写的，这个库使得C语言有了面向对象的能力。<br><a id="more"></a></p>
<p><strong>Runtime库主要做下面几件事：</strong><br><strong>封装</strong>：在这个库中，对象可以用C语言中的结构体表示，而方法可以用C函数来实现，另外再加上了一些额外的特性。这些结构体和函数被<code>runtime</code>函数封装后，我们就可以在程序运行时创建，检查，修改类、对象和它们的方法了。</p>
<p><strong>找出方法的最终执行代码</strong>：当程序执行<code>[object doSomething]</code>时，会向消息接收者(object)发送一条消息(doSomething)，<code>runtime</code>会根据消息接收者是否能响应该消息而做出不同的反应。</p>
<h3 id="基本解释"><a href="#基本解释" class="headerlink" title="基本解释"></a>基本解释</h3><ul>
<li>Runtime 是一套比较底层的纯C语言API, 它是OC的幕后工作者</li>
<li>我们平时写的OC代码在运行时都会编译器转为runtime的C语言代码</li>
<li>其中最主要的是消息机制OC的函数调用成为消息发送 属于动态调用过程 在编译的时候并不能决定真正调用哪个函数</li>
<li>事实证明, 在编译阶段，OC可以调用任何函数，即使这个函数并未实现，只要申明过就不会报错</li>
<li>而C语言在编译阶段就会报错 只有在真正运行的时候才会根据函数的名称找到对应的函数来调用。</li>
</ul>
<h2 id="实际用法"><a href="#实际用法" class="headerlink" title="实际用法"></a>实际用法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div></pre></td><td class="code"><pre><div class="line">#import &quot;ViewController.h&quot;</div><div class="line">#import &lt;objc/runtime.h&gt;</div><div class="line">#import &lt;objc/message.h&gt;</div><div class="line">#import &quot;Person.h&quot;</div><div class="line">#import &quot;NSObject+my.h&quot;</div><div class="line"></div><div class="line"></div><div class="line">@interface ViewController ()</div><div class="line">@property (weak, nonatomic) IBOutlet UIImageView *phoneImg;</div><div class="line"></div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">@implementation ViewController</div><div class="line"></div><div class="line">- (void)viewDidLoad &#123;</div><div class="line">    [super viewDidLoad];</div><div class="line">    </div><div class="line">    /******************1.消息发送*******************/</div><div class="line">    </div><div class="line">    Person *p = [Person new];</div><div class="line">//    [p run];</div><div class="line">    objc_msgSend(p,@selector(run));</div><div class="line">    </div><div class="line">    objc_msgSend([Person class], @selector(run));</div><div class="line"></div><div class="line">    /******************2.方法交换*******************/</div><div class="line">    self.phoneImg.image = [UIImage imageNamed:@&quot;banner&quot;];</div><div class="line">    </div><div class="line">    /******************3.获取实例变量*******************/</div><div class="line">    </div><div class="line">    //参数1:你要获取的类,参数2:数量指针</div><div class="line">    </div><div class="line">    unsigned int iVarCount;</div><div class="line">    </div><div class="line">    Ivar *iVarList = class_copyIvarList([Person class], &amp;iVarCount);</div><div class="line">    </div><div class="line">    for (int i = 0; i &lt; iVarCount; i++) &#123;</div><div class="line">        </div><div class="line">        Ivar aVar = iVarList[i];</div><div class="line">        </div><div class="line">        NSLog(@&quot;%s&quot;,ivar_getName(aVar));</div><div class="line">    &#125;</div><div class="line">    /******************4.获取对象方法*******************/</div><div class="line">    unsigned int methodCount;</div><div class="line">    </div><div class="line">    Method *methodList = class_copyMethodList([Person class], &amp;methodCount);</div><div class="line">    </div><div class="line">    for (int i = 0; i &lt; methodCount; i++) &#123;</div><div class="line">        </div><div class="line">        Method aMethod = methodList[i];</div><div class="line">        </div><div class="line">        SEL methodSel = method_getName(aMethod);</div><div class="line">        </div><div class="line">        NSLog(@&quot;%@&quot;,NSStringFromSelector(methodSel));</div><div class="line"></div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    /******************5.动态创建类,添加实例变量*******************/</div><div class="line">    </div><div class="line">    //创建一个类 参数1:父类 参数2:你要创建的类名 参数3:</div><div class="line">     Class MyClass = objc_allocateClassPair([Person class], &quot;MyClass&quot;, 0);</div><div class="line">    </div><div class="line">    </div><div class="line">    //添加实例变量  参数1:要往哪个类添加, 参数2:变量名 参数3:变量大小 参数4:对齐方式-传0 参数5:类型编码(要去文档查看)</div><div class="line">    </div><div class="line">    </div><div class="line">    if (class_addIvar(MyClass, &quot;_city&quot;, sizeof(NSString *), 0, &quot;@&quot;)) &#123;</div><div class="line">        NSLog(@&quot;变量添加成功&quot;);</div><div class="line">        </div><div class="line">        </div><div class="line">        id myP = [[MyClass alloc]init];//使用id类型来接收</div><div class="line">        </div><div class="line">        //赋值</div><div class="line">        [myP setValue:@&quot;广州&quot; forKey:@&quot;_city&quot;];</div><div class="line">        </div><div class="line">        //取出</div><div class="line">        NSLog(@&quot;%@&quot;,[myP valueForKey:@&quot;_city&quot;]);</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    /******************6.动态创建类,添加对象方法*******************/</div><div class="line">    </div><div class="line">    //添加对象方法  参数1:要往哪个类添加, 参数2:方法选择器 参数3:实现 参数4:实现的函数类型编码(要去文档查看)</div><div class="line">    </div><div class="line">    if (class_addMethod(MyClass, @selector(aMethod:), (IMP)aMethod_IMP, &quot;v@:@&quot;)) &#123;</div><div class="line">        </div><div class="line">        NSLog(@&quot;方法添加成功&quot;);</div><div class="line">        </div><div class="line">        id myP = [[MyClass alloc]init];//使用id类型来接收</div><div class="line">        </div><div class="line">        [myP aMethod:@&quot;哈哈&quot;];</div><div class="line">        </div><div class="line">        </div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    /******************7.分类添加属性*******************/</div><div class="line">    </div><div class="line">    NSObject *obj = [NSObject new];</div><div class="line"></div><div class="line">    obj.myName = @&quot;aNema&quot;;</div><div class="line">    </div><div class="line">    NSLog(@&quot;%@&quot;,obj.myName);</div><div class="line">    </div><div class="line">    </div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">//方法实现</div><div class="line">void aMethod_IMP(id self,SEL _cmd,NSString * str)&#123;</div><div class="line"></div><div class="line">    NSLog(@&quot;%s = %@&quot;,__func__,str);</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">//OC里的方法</div><div class="line">- (void)aMethod:(NSString *)str&#123;</div><div class="line">    </div><div class="line">    NSLog(@&quot;%s&quot;,__func__);</div><div class="line">    </div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>###UIImage分类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line">//</div><div class="line">//  UIImage+my.m</div><div class="line">//  01-runtime</div><div class="line">//</div><div class="line">//  Created by iOS on 15/12/24.</div><div class="line">//  Copyright © 2015年 iOS. All rights reserved.</div><div class="line">//</div><div class="line"></div><div class="line">#import &quot;UIImage+my.h&quot;</div><div class="line">#import &lt;objc/runtime.h&gt;</div><div class="line"></div><div class="line">@implementation UIImage (my)</div><div class="line"></div><div class="line">+ (void)load&#123;</div><div class="line">    </div><div class="line">    //1.获取旧方法</div><div class="line">    </div><div class="line">    Method imageNameM = class_getClassMethod(self, @selector(imageNamed:));</div><div class="line">    </div><div class="line">    //2.获取新方法</div><div class="line">    Method imageWithNameM = class_getClassMethod(self, @selector(imageWithName:));</div><div class="line">    </div><div class="line">    //3.交换</div><div class="line">    </div><div class="line">    method_exchangeImplementations(imageNameM, imageWithNameM);</div><div class="line">    </div><div class="line">    </div><div class="line">    </div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">//+ (UIImage *)imageNamed:(NSString *)name&#123;</div><div class="line">//    </div><div class="line">//&#125;</div><div class="line"></div><div class="line"></div><div class="line">+ (UIImage *)imageWithName:(NSString *)name&#123;</div><div class="line">    </div><div class="line">    NSLog(@&quot;%s&quot;,__func__);</div><div class="line">    </div><div class="line">    if ([UIDevice currentDevice].userInterfaceIdiom == UIUserInterfaceIdiomPad) &#123;</div><div class="line">        </div><div class="line">        name = [name stringByAppendingString:@&quot;_iPad&quot;];</div><div class="line">        </div><div class="line">    &#125;else &#123;</div><div class="line">        name = [name stringByAppendingString:@&quot;_iPhone&quot;];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line"></div><div class="line">    return [self imageWithName:name];</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure></p>
<p>###NSObject分类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">//</div><div class="line">//  NSObject+my.m</div><div class="line">//  01-runtime</div><div class="line">//</div><div class="line">//  Created by iOS on 15/12/24.</div><div class="line">//  Copyright © 2015年 iOS. All rights reserved.</div><div class="line">//</div><div class="line"></div><div class="line">#import &quot;NSObject+my.h&quot;</div><div class="line">#import &lt;objc/runtime.h&gt;</div><div class="line"></div><div class="line">@implementation NSObject (my)</div><div class="line"></div><div class="line">static const void *myNameKey = &quot;myNameKey&quot;;</div><div class="line"></div><div class="line">- (void)setMyName:(NSString *)myName&#123;</div><div class="line">    </div><div class="line">//    [self setValue:myName forKey:@&quot;myName&quot;];</div><div class="line">    </div><div class="line">    //设置关联  参数1:要关联的对象 参数2:绑定的key 参数3:这个key要关联的值 参数4:要使用的策略</div><div class="line">    objc_setAssociatedObject(self, myNameKey, myName, OBJC_ASSOCIATION_COPY_NONATOMIC);</div><div class="line">    </div><div class="line">&#125;</div><div class="line"></div><div class="line">- (NSString *)myName&#123;</div><div class="line">    </div><div class="line">//    return [self valueForKey:@&quot;myName&quot;];</div><div class="line">    return objc_getAssociatedObject(self, myNameKey);</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[iOS直播-基于RTMP的视频推送]]></title>
      <url>http://jimmypeng.cn/2016/05/21/pushRTMP/</url>
      <content type="html"><![CDATA[<p>所谓的视频推送就是把摄像头和麦克风捕获到视频和音频推送到直播服务器上.<br>我们这里使用推送协议是<strong>RTMP</strong>协议.<br>腾讯直播平台,阿里直播平台,百度直播平台提供均为RTMP的推流和HLS/RTMP等拉流.</p>
<p>我们使用<code>GDLiveStreaming</code>来实现iOS端的视频推送</p>
<h3 id="GDLiveStreaming简介"><a href="#GDLiveStreaming简介" class="headerlink" title="GDLiveStreaming简介"></a>GDLiveStreaming简介</h3><p><code>GDLiveStreaming</code>是对开源框架<code>VideoCore</code>简单封装.提供视频录制,推送与存储. 你可以下载<code>GDLiveStreaming</code>源码来学习和研究.<br>我们这里讲解如何通过`GDLiveStreaming实现RTMP的推流</p>
<a id="more"></a>
<h3 id="集成GDLiveStreaming步骤"><a href="#集成GDLiveStreaming步骤" class="headerlink" title="集成GDLiveStreaming步骤"></a>集成GDLiveStreaming步骤</h3><ol>
<li>创建项目</li>
<li>打开终端<code>cd</code>到项目目录</li>
<li>执行<code>pod init</code> 生成 <code>Profile</code>文件</li>
<li>在 <code>target yourFileName do</code> 与 <code>end</code>之间添加</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">pod &apos;GDLiveStreaming&apos;, :git =&gt; &apos;https://github.com/goodow/GDLiveStreaming.git&apos;</div><div class="line">pod &apos;VideoCore&apos;, :git =&gt; &apos;https://github.com/goodow/VideoCore.git&apos;</div><div class="line">pod &apos;glm&apos;, :podspec =&gt; &apos;https://raw.githubusercontent.com/goodow/GDLiveStreaming/master/glm.podspec&apos;</div></pre></td></tr></table></figure>
<ol>
<li>执行 pod install 命令, 等待其安装完毕, 打开 .<code>xcworkspace</code>文件.<br>到此GDLiveStreaming安装完毕.</li>
</ol>
<h3 id="GDLiveStreaming基本使用"><a href="#GDLiveStreaming基本使用" class="headerlink" title="GDLiveStreaming基本使用"></a>GDLiveStreaming基本使用</h3><p>导入如下头文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">#import &lt;GPUImage/GPUImageVideoCamera.h&gt;</div><div class="line">#import &lt;GPUImage/GPUImageView.h&gt;</div><div class="line">#import &lt;GDLiveStreaming/GDLRawDataOutput.h&gt;</div></pre></td></tr></table></figure>
<h3 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h3><ol>
<li>创建视频摄像头</li>
<li>设置摄像头帧率</li>
<li>设置摄像头输出图片的方向</li>
<li>创建用于展示视频的GPUImageView</li>
<li>添加GPUImageView为摄像头的的输出目标</li>
<li>创建GDLRawDataOutput对象</li>
<li>添加数据输出对象为摄像头输出目标</li>
<li>开始捕获视频</li>
<li>开始上传视频</li>
</ol>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> *  用于捕获视频的摄像头</div><div class="line"> */</div><div class="line">@property (nonatomic, strong) GPUImageVideoCamera *camera;</div><div class="line"></div><div class="line">/**</div><div class="line"> *  用于视频上传的输出对象</div><div class="line"> */</div><div class="line">@property (nonatomic, strong) GDLRawDataOutput *output;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">//  1. 创建视频摄像头</div><div class="line">    self.camera = [[GPUImageVideoCamera alloc] initWithSessionPreset:AVCaptureSessionPreset1280x720</div><div class="line">cameraPosition:AVCaptureDevicePositionBack];</div><div class="line">//  2. 设置摄像头帧率</div><div class="line">    self.camera.frameRate = 20;</div><div class="line">//  3. 设置摄像头输出视频的方向</div><div class="line">    self.camera.outputImageOrientation = UIInterfaceOrientationPortrait;</div><div class="line">//  4.0 创建用于展示视频的GPUImageView</div><div class="line">    GPUImageView *imageView = [[GPUImageView alloc] init];</div><div class="line">    imageView.frame = self.view.bounds;</div><div class="line">    [self.view addSubview:imageView];</div><div class="line">//  4.1 添加GPUImageView为摄像头的的输出目标</div><div class="line">    [self.camera addTarget:imageView];</div><div class="line">//  5. 创建原始数据输出对象</div><div class="line"></div><div class="line">    GDLRawDataOutput *output = [[GDLRawDataOutput alloc] initWithVideoCamera:self.camera withImageSize:CGSizeMake(720, 1280)];</div><div class="line"></div><div class="line">//  6. 添加数据输出对象为摄像头输出目标</div><div class="line">    [self.camera addTarget:output];</div><div class="line"></div><div class="line">//  7.开始捕获视频</div><div class="line">    [self.camera startCameraCapture];</div><div class="line"></div><div class="line">//  8.开始上传视频</div><div class="line">    [output startUploadStreamWithURL:@&quot;rtmp://172.16.88.27:1935/Jimmy&quot; andStre  amKey:@&quot;room&quot;];</div></pre></td></tr></table></figure>
<h3 id="GDLiveStreaming扩展"><a href="#GDLiveStreaming扩展" class="headerlink" title="GDLiveStreaming扩展"></a>GDLiveStreaming扩展</h3><ul>
<li><strong>GPUImageVideoCamera常见常用方法</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">/** 开始捕获</div><div class="line"> */</div><div class="line">- (void)startCameraCapture;</div><div class="line">/** 停止捕获</div><div class="line"> */</div><div class="line">- (void)stopCameraCapture;</div><div class="line">/**暂停捕获</div><div class="line"> */</div><div class="line">- (void)pauseCameraCapture;</div><div class="line">/**恢复捕获</div><div class="line"> */</div><div class="line">- (void)resumeCameraCapture;</div><div class="line">///前置摄像头与后置摄像头切换</div><div class="line">- (void)rotateCamera</div></pre></td></tr></table></figure>
<ul>
<li><strong>GDLRawDataOutput常见常用方法</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">///开始上传视频流, streamKey是拼接在rtmpUrl后面的路径名称,可以理解为视频的直播中的房间编号.</div><div class="line">- (void)startUploadStreamWithURL:(NSString *)rtmpUrl andStreamKey:(NSString *)streamKey;</div><div class="line">///停止上传视频流</div><div class="line">- (void)stopUploadStream;</div></pre></td></tr></table></figure>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[iOS直播-播放基于RTMP协议的视频]]></title>
      <url>http://jimmypeng.cn/2016/05/21/playRTMP/</url>
      <content type="html"><![CDATA[<h3 id="流媒体协议介绍"><a href="#流媒体协议介绍" class="headerlink" title="流媒体协议介绍"></a>流媒体协议介绍</h3><h4 id="1-伪流媒体"><a href="#1-伪流媒体" class="headerlink" title="1. 伪流媒体:"></a>1. 伪流媒体:</h4><ul>
<li><strong>渐进式下载</strong> : 边下边存, 文件会保存</li>
<li><strong>使用http协议</strong>, 也能够实现视频播放, 也能快进快退等, 体验上跟流媒体很像. 优酷, 土豆.这些网站就在使用这项技术.<ul>
<li><strong>特点</strong>:实现简单, 成本也低</li>
</ul>
</li>
</ul>
<h4 id="2-流媒体"><a href="#2-流媒体" class="headerlink" title="2. 流媒体:"></a>2. 流媒体:</h4><p>边下边播, 不会保存文件,特点:流过就没有了.常用的协议有两个,分别为</p>
<ul>
<li><strong>HLS</strong> (HTTP Live Streaming)</li>
<li><strong>RTMP</strong> (Real Time Messaging Protocol)</li>
</ul>
<a id="more"></a>
<p><strong>HLS (HTTP Live Streaming)</strong>，Apple的动态码率自适应技术。主要用于Mac和iOS音视频服务。包括一个m3u(8)的索引文件(.M3u8)，多个TS媒体分片文件(.ts)和key加密串文件。支持推流和播放. iOS自带的播放器就可以直接播放基于HLS协议的视频.</p>
<p><strong>RTMP是Real Time Messaging Protocol</strong>（实时消息传输协议）的首字母缩写。该协议基于TCP，是一个协议族，包括RTMP基本协议及RTMPT/RTMPS/RTMPE等多种变种。RTMP是一种设计用来进行实时数据通信的网络协议，主要用来在Flash/AIR平台和支持RTMP协议的流媒体/交互服务器之间进行音视频和数据通信.</p>
<p>RTMP(Real Time Messaging Protocol)实时消息传送协议是Adobe Systems公司为Flash播放器和服务器之间音频、视频和数据传输 开发的开放协议。<br>它有多种变种：</p>
<ul>
<li>RTMP工作在TCP之上，默认使用端口1935；</li>
<li>RTMPE在RTMP的基础上增加了加密功能；</li>
<li>RTMPT封装在HTTP请求之上，可穿透防火墙；</li>
<li>RTMPS类似RTMPT，增加了TLS/SSL的安全功能；</li>
</ul>
<h3 id="3-iOS实现基于视频RTMP的视频直播"><a href="#3-iOS实现基于视频RTMP的视频直播" class="headerlink" title="3. iOS实现基于视频RTMP的视频直播"></a>3. iOS实现基于视频RTMP的视频直播</h3><h4 id="3-1-RTMP协议的视频播放"><a href="#3-1-RTMP协议的视频播放" class="headerlink" title="3.1 RTMP协议的视频播放"></a>3.1 RTMP协议的视频播放</h4><h5 id="3-1-1-IJKPlayer简介"><a href="#3-1-1-IJKPlayer简介" class="headerlink" title="3.1.1 IJKPlayer简介"></a>3.1.1 IJKPlayer简介</h5><ul>
<li>我们使用<code>Bilibili</code>开源的<a href="https://github.com/Bilibili/ijkplayer" target="_blank" rel="external">IJKPlayer</a>,来实现RTMP协议下的视频播放</li>
<li>ijkplayer 是<code>bilibili</code>对开源框架<a href="https://github.com/FFmpeg/FFmpeg" target="_blank" rel="external">FFmpeg</a>(一个基于C的软解码视频播放开源框架)的封装.他使用起来更加方便和简单.<h5 id="3-1-2-下载并编译iOS版的ijkplayer"><a href="#3-1-2-下载并编译iOS版的ijkplayer" class="headerlink" title="3.1.2 下载并编译iOS版的ijkplayer"></a>3.1.2 下载并编译iOS版的ijkplayer</h5></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">#下载 ijkplayer-ios</div><div class="line">git clone https://github.com/Bilibili/ijkplayer.git ijkplayer-ios</div><div class="line">#到` ijkplayer-ios`目录中</div><div class="line">cd ijkplayer-ios</div><div class="line">#切换到 `k0.5.1` 分支</div><div class="line">git checkout -B latest k0.5.1</div><div class="line">#运行iOS初始化脚本</div><div class="line">./init-ios.sh</div><div class="line">#进入到 iOS 文件夹</div><div class="line">cd iOS</div><div class="line">#清空编译</div><div class="line">./compile-ffmpeg.sh clean</div><div class="line">#编译全部,比较耗时,需要等待</div><div class="line">./compile-ffmpeg.sh all</div><div class="line">#使用Xcode打开ios文件夹下面的 IJKMediaPlayer 项目,分别在模拟器和真机上编译IJKMediaFramework.framework.</div></pre></td></tr></table></figure>
<p><img src="http://7xpbws.com1.z0.glb.clouddn.com/blogrtmp1.png" alt="Alt text"></p>
<p>编译后一个用于模拟器一个用于真机</p>
<p><img src="http://7xpbws.com1.z0.glb.clouddn.com/blogrtmp2.png" alt="Alt text"></p>
<p>附: 如果你想把两个framework进行合并,可以使用lips -create  文件1  文件2  -o  要生成文件</p>
<p><img src="http://7xpbws.com1.z0.glb.clouddn.com/blogrtmp3.png" alt="Alt text"></p>
<p><strong>注意:在测试阶段可以使用合并后的framework,当打包时候最好只使用真机的framework以减小安装包的大小</strong></p>
<h5 id="3-1-3-IJKMediaFramework-framework的基本使用"><a href="#3-1-3-IJKMediaFramework-framework的基本使用" class="headerlink" title="3.1.3 IJKMediaFramework.framework的基本使用"></a>3.1.3 IJKMediaFramework.framework的基本使用</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line">- (void)viewDidLoad &#123;</div><div class="line">    [super viewDidLoad];</div><div class="line">//1. 根据当前环境设置日志信息</div><div class="line">//1.1如果是Debug状态的</div><div class="line">#ifdef DEBUG</div><div class="line">//  设置报告日志</div><div class="line">    [IJKFFMoviePlayerController setLogReport:YES];</div><div class="line">//  设置日志的级别为Debug</div><div class="line">    [IJKFFMoviePlayerController setLogLevel:k_IJK_LOG_DEBUG];</div><div class="line">//1.2否则(如果不是debug状态的)</div><div class="line">#else</div><div class="line">//  设置不报告日志</div><div class="line">    [IJKFFMoviePlayerController setLogReport:NO];</div><div class="line">//  设置日志级别为信息</div><div class="line">    [IJKFFMoviePlayerController setLogLevel:k_IJK_LOG_INFO];</div><div class="line">#endif</div><div class="line"></div><div class="line">// 2. 检查版本是否匹配</div><div class="line">    [IJKFFMoviePlayerController checkIfFFmpegVersionMatch:YES];</div><div class="line">// 3.  创建IJKFFMoviePlayerController</div><div class="line">// 3.1 默认选项配置</div><div class="line">    IJKFFOptions *options = [IJKFFOptions optionsByDefault];</div><div class="line">// 3.2 创建播放控制器</div><div class="line">    IJKFFMoviePlayerController *ffMoviePlayerController = [[IJKFFMoviePlayerController alloc] initWithContentURLString:@&quot;rtmp://192.168.41.35:1935/gzhm/room&quot; withOptions: options];</div><div class="line">//4. 屏幕适配</div><div class="line">// 4.1 设置播放视频视图的frame与控制器的View的bounds一致 </div><div class="line">    self.player.view.frame = self.view.bounds;</div><div class="line">// 4.2 设置适配横竖屏(设置四边固定,长宽灵活)</div><div class="line">    self.player.view.autoresizingMask = UIViewAutoresizingFlexibleWidth|UIViewAutoresizingFlexibleHeight;</div><div class="line">//  4.3 设置播放视图的缩放模式</div><div class="line">    self.player.scalingMode = IJKMPMovieScalingModeAspectFit;</div><div class="line">//  4.4 设置自动播放</div><div class="line">    self.player.shouldAutoplay = YES;</div><div class="line">//  4.5 自动更新子视图的大小</div><div class="line">    self.view.autoresizesSubviews = YES;</div><div class="line">//  4.6 添加播放视图到控制器的View</div><div class="line">    [self.view addSubview:self.player.view];</div><div class="line">&#125;</div><div class="line"></div><div class="line">#pragma mark - 视图即将显示</div><div class="line">- (void)viewWillAppear:(BOOL)animated &#123;</div><div class="line">    [super viewWillAppear:animated];</div><div class="line">//  当试图即将展示的时候开始播放</div><div class="line">    [self.player prepareToPlay];</div><div class="line">&#125;</div><div class="line">#pragma mark - 视图已经消失</div><div class="line">- (void)viewDidDisappear:(BOOL)animated &#123;</div><div class="line">    [super viewDidDisappear:animated];</div><div class="line">//  关闭播放</div><div class="line">    [self.player shutdown];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="3-1-4-暂停与播放"><a href="#3-1-4-暂停与播放" class="headerlink" title="3.1.4 暂停与播放"></a>3.1.4 暂停与播放</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">- (IBAction)play:(id)sender &#123;</div><div class="line">//  播放</div><div class="line">    [self.player play];</div><div class="line">&#125;</div><div class="line">- (IBAction)pause:(id)sender &#123;</div><div class="line">// 暂停</div><div class="line">    [self.player pause];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="3-1-5-添加播放状态的监听"><a href="#3-1-5-添加播放状态的监听" class="headerlink" title="3.1.5 添加播放状态的监听"></a>3.1.5 添加播放状态的监听</h5><p><code>IJKFFMoviePlayerController</code> 支持的通知有很多,常见的有:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">IJKMPMoviePlayerLoadStateDidChangeNotification(加载状态改变通知)</div><div class="line">IJKMPMoviePlayerPlaybackDidFinishNotification(播放结束通知)</div><div class="line">IJKMPMoviePlayerPlaybackStateDidChangeNotification(播放状态改变通知)</div></pre></td></tr></table></figure>
<p>步骤:</p>
<ul>
<li>在viewWillAppear添加监听</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">//  1. 添加播放状态改变的通知</div><div class="line">    [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(playbackStateDidChange:) name:IJKMPMoviePlayerPlaybackStateDidChangeNotification object:self.player];</div></pre></td></tr></table></figure>
<ul>
<li>实现监听方法</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">- (void) playbackStateDidChange:(NSNotification *) notification &#123;</div><div class="line"></div><div class="line">//    NSLog(@&quot;%@&quot;,notification);</div><div class="line">//    IJKMPMoviePlaybackStateStopped,        停止</div><div class="line">//    IJKMPMoviePlaybackStatePlaying,        正在播放</div><div class="line">//    IJKMPMoviePlaybackStatePaused,         暂停</div><div class="line">//    IJKMPMoviePlaybackStateInterrupted,    打断</div><div class="line">//    IJKMPMoviePlaybackStateSeekingForward, 快进</div><div class="line">//    IJKMPMoviePlaybackStateSeekingBackward 快退</div><div class="line"></div><div class="line"></div><div class="line">    switch (self.player.playbackState) &#123;</div><div class="line">        case IJKMPMoviePlaybackStateStopped:</div><div class="line">            NSLog(@&quot;停止&quot;);</div><div class="line">            break;</div><div class="line">        case IJKMPMoviePlaybackStatePlaying:</div><div class="line">            NSLog(@&quot;正在播放&quot;);</div><div class="line">            break;</div><div class="line">        case IJKMPMoviePlaybackStatePaused:</div><div class="line">            NSLog(@&quot;暂停&quot;);</div><div class="line">            break;</div><div class="line">        case IJKMPMoviePlaybackStateInterrupted:</div><div class="line">            NSLog(@&quot;打断&quot;);</div><div class="line">            break;</div><div class="line">        case IJKMPMoviePlaybackStateSeekingForward:</div><div class="line">            NSLog(@&quot;快进&quot;);</div><div class="line">            break;</div><div class="line">        case IJKMPMoviePlaybackStateSeekingBackward:</div><div class="line">            NSLog(@&quot;快退&quot;);</div><div class="line">            break;</div><div class="line">        default:</div><div class="line">            break;</div><div class="line">    &#125;   </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>在viewDidDisappear移除监听</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[[NSNotificationCenter defaultCenter] removeObserver:self name:IJKMPMoviePlayerPlaybackStateDidChangeNotification object:self.player];</div></pre></td></tr></table></figure>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Mac上搭建直播服务器Nginx]]></title>
      <url>http://jimmypeng.cn/2016/05/21/Ngnix/</url>
      <content type="html"><![CDATA[<h3 id="1-安装Homebrew，执行命令"><a href="#1-安装Homebrew，执行命令" class="headerlink" title="1.安装Homebrew，执行命令"></a>1.安装Homebrew，执行命令</h3><p>Homebrew简称brew，是Mac OSX上的软件包管理工具，能在Mac中方便的安装软件或者卸载软件，可以说Homebrew就是mac下的apt-get、yum神器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</div></pre></td></tr></table></figure>
<h3 id="2-安装Nginx服务器"><a href="#2-安装Nginx服务器" class="headerlink" title="2. 安装Nginx服务器"></a>2. 安装Nginx服务器</h3><p>增加对 <strong>nginx</strong> 的扩展;<br>也就是从github上下载,home-brew对ngixnx的扩展</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">brew tap homebrew/nginx</div></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="3-安装Nginx服务器和rtmp模块"><a href="#3-安装Nginx服务器和rtmp模块" class="headerlink" title="3. 安装Nginx服务器和rtmp模块"></a>3. 安装Nginx服务器和rtmp模块</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">brew install nginx-full --with-rtmp-module</div></pre></td></tr></table></figure>
<h3 id="4-配置nginx的ramp模块"><a href="#4-配置nginx的ramp模块" class="headerlink" title="4. 配置nginx的ramp模块"></a>4. 配置nginx的ramp模块</h3><p>查看nginx-full信息<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">brew info nginx-full</div></pre></td></tr></table></figure></p>
<p>执行上面的命令后我们可以看到如下信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">Docroot is: /usr/local/var/www</div><div class="line"></div><div class="line">The default port has been set in /usr/local/etc/nginx/nginx.conf to 8080 so that</div><div class="line">nginx can run without sudo.</div><div class="line"></div><div class="line">nginx will load all files in /usr/local/etc/nginx/servers/.</div><div class="line"></div><div class="line">- Tips -</div><div class="line">Run port 80:</div><div class="line"> $ sudo chown root:wheel /usr/local/Cellar/nginx-full/1.10.0/bin/nginx</div><div class="line"> $ sudo chmod u+s /usr/local/Cellar/nginx-full/1.10.0/bin/nginx</div><div class="line">Reload config:</div><div class="line"> $ nginx -s reload     #重新加载配置文件</div><div class="line">Reopen Logfile:</div><div class="line"> $ nginx -s reopen   #再次打开日志文件</div><div class="line">Stop process:</div><div class="line"> $ nginx -s stop           #停止服务器</div><div class="line">Waiting on exit process</div><div class="line"> $ nginx -s quit           #退出服务器</div></pre></td></tr></table></figure>
<h4 id="从上面可以看出"><a href="#从上面可以看出" class="headerlink" title="从上面可以看出"></a>从上面可以看出</h4><ol>
<li>nginx安装所在位置</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/usr/local/Cellar/nginx-full/</div></pre></td></tr></table></figure>
<ol>
<li>nginx配置文件所在位置</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/usr/local/etc/nginx/nginx.conf</div></pre></td></tr></table></figure>
<ol>
<li>nginx服务器根目录所在位置</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/usr/local/var/www</div></pre></td></tr></table></figure>
<ol>
<li>执行命令 ，测试下是否能成功启动nginx服务</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/usr/local/Cellar/nginx-full/1.10.1/bin/nginx</div></pre></td></tr></table></figure>
<h4 id="在浏览器地址栏输入：http-localhost-8080-如果出现"><a href="#在浏览器地址栏输入：http-localhost-8080-如果出现" class="headerlink" title="在浏览器地址栏输入：http://localhost:8080 如果出现"></a>在浏览器地址栏输入：<code>http://localhost:8080</code> 如果出现</h4><h1 id="Welcome-to-nginx"><a href="#Welcome-to-nginx" class="headerlink" title="Welcome to nginx!"></a>Welcome to nginx!</h1><p>代表nginx安装成功了</p>
<h3 id="5-修改nginx-conf这个配置文件，配置rtmp"><a href="#5-修改nginx-conf这个配置文件，配置rtmp" class="headerlink" title="5. 修改nginx.conf这个配置文件，配置rtmp"></a>5. 修改nginx.conf这个配置文件，配置rtmp</h3><p>用Xcode打开nginx.conf, 找到<code>/usr/local/etc/nginx/nginx.conf</code> 文件<br>拖入到Dock中的Xcode,就可以打开.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">http &#123;</div><div class="line">    ……</div><div class="line">&#125;</div><div class="line">#在http节点下面(也就是文件的尾部)加上rtmp配置：</div><div class="line">rtmp &#123;</div><div class="line">    server &#123;</div><div class="line">        listen 1935;</div><div class="line">        application Jimmy &#123;</div><div class="line">            live on;</div><div class="line">            record off;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>说明:<ol>
<li>rtmp是协议名称</li>
<li>server 说明内部中是服务器相关配置</li>
<li>listen 监听的端口号, rtmp协议的默认端口号是1935</li>
<li>application 访问的应用路径是 Jimmy</li>
<li>live on; 开启实时</li>
<li>record off; 不记录数据</li>
</ol>
</li>
</ul>
<h3 id="6-保存文件后，重新加载nginx的配置文件"><a href="#6-保存文件后，重新加载nginx的配置文件" class="headerlink" title="6. 保存文件后，重新加载nginx的配置文件"></a>6. 保存文件后，重新加载nginx的配置文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">nginx -s reload</div></pre></td></tr></table></figure>
<h3 id="7-安装ffmepg工具"><a href="#7-安装ffmepg工具" class="headerlink" title="7. 安装ffmepg工具"></a>7. 安装ffmepg工具</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">brew install ffmpeg</div></pre></td></tr></table></figure>
<p>安装这个需要等一段时间, 这时你可以准备一个视频文件作为来推流，然后安装一个支持rtmp协议的视频播放器.</p>
<h4 id="Mac下可以用-VLC"><a href="#Mac下可以用-VLC" class="headerlink" title="Mac下可以用 VLC"></a>Mac下可以用 <a href="http://rj.baidu.com/soft/detail/25680.html?ald" target="_blank" rel="external">VLC</a></h4><h3 id="8-通过ffmepg命令进行推流"><a href="#8-通过ffmepg命令进行推流" class="headerlink" title="8. 通过ffmepg命令进行推流"></a>8. 通过ffmepg命令进行推流</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ffmpeg -re -i 你的视频文件的绝对路径(如/Users/Jimmy/desktop/myVideo.mp4)  -vcodec copy -f flv rtmp://localhost:1935/Jimmy/room</div></pre></td></tr></table></figure>
<p>这里Jimmy是上面的配置文件中,配置的应用的路径名称;后面的room可以随便写.</p>
<h3 id="9-验证视频"><a href="#9-验证视频" class="headerlink" title="9. 验证视频"></a>9. 验证视频</h3><p>然后电脑上打开vlc这个播放器软件 点击File—-&gt;Open Network 在弹出来的框中选择Network然后输入URL:</p>
<p>rtmp://localhost:1935/Jimmy/room</p>
<p>如图:</p>
<p><img src="http://7xpbws.com1.z0.glb.clouddn.com/blognginx.png" alt="Alt text"></p>
<p>播放界面:</p>
<p><img src="http://7xpbws.com1.z0.glb.clouddn.com/blogngnix2.png" alt="Alt text"></p>
<h4 id="9-可能会遇到的问题"><a href="#9-可能会遇到的问题" class="headerlink" title="9. 可能会遇到的问题"></a>9. 可能会遇到的问题</h4><p>找不到C语言的编译器clang</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;font&gt;错误信息:</div><div class="line">checking for OS</div><div class="line">+ Darwin 15.3.0 x86_64</div><div class="line">checking for C compiler ... not found</div><div class="line">./configure: error: C compiler clang is not found</div></pre></td></tr></table></figure>
<p><strong>解决方案:</strong><br>需要去apple官网下载命令行工具,安装即可. 注意命令行工具的版本需要和你的Xcode对应.</p>
<p>参考文章:<br>    <a href="http://www.cnblogs.com/damiao/p/5231221.html" target="_blank" rel="external">OSX安装nginx和rtmp模块（rtmp直播服务器搭建）</a><br><a href="http://brew.sh/index_zh-cn.html" target="_blank" rel="external">Homebrew</a><br><a href="https://icyleaf.com/2014/01/homebrew-hidden-commands/" target="_blank" rel="external">Homebrew 隐藏命令</a><br><a href="http://www.jianshu.com/p/5ee84e403ea8" target="_blank" rel="external">搭建直播服务器Nginx</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[iOS6、7、8、9新特性汇总和适配说明]]></title>
      <url>http://jimmypeng.cn/2016/02/15/ios6789/</url>
      <content type="html"><![CDATA[<h1 id="iOS6新特性"><a href="#iOS6新特性" class="headerlink" title="iOS6新特性"></a>iOS6新特性</h1><hr>
<h5 id="一、关于内存警告"><a href="#一、关于内存警告" class="headerlink" title="一、关于内存警告"></a>一、关于内存警告</h5><p>ios6中废除了viewDidUnload，viewWillUnload这两个系统回调，收到内存警告时在didReceiveMemoryWarning中进行相关的处理。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">- (void)viewDidUnload &#123;</div><div class="line">    [super viewDidUnload];</div><div class="line">    // 处理 ios6 以下的系统内存警告系统回调消息</div><div class="line">&#125;</div><div class="line"> </div><div class="line">// 这里处理ios6 的内存警告</div><div class="line">- (void)didReceiveMemoryWarning &#123;</div><div class="line">    [super didReceiveMemoryWarning];</div><div class="line">    </div><div class="line">    float sysVer = [[[UIDevice currentDevice] systemVersion] floatValue];</div><div class="line">    //ios6 的特殊处理</div><div class="line">    </div><div class="line">    if (sysVer &gt;= 6.0f) &#123;</div><div class="line">        // 保证 invisible,  因为即使在当前界面也会收到系统回调</div><div class="line">        if (self.view.window == nil) &#123;</div><div class="line">            //.......</div><div class="line">            // 做相关的释放操作</div><div class="line">            self.view = nil;   // 确保下次会重新加载</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<a id="more"></a>
<h5 id="二、关于屏幕旋转"><a href="#二、关于屏幕旋转" class="headerlink" title="二、关于屏幕旋转"></a>二、关于屏幕旋转</h5><p>同样ios6 废除了shouldAutorotateToInterfaceOrientation这个旋转屏幕的设置接口。</p>
<p>必须在两个新接口中设置旋转属性:shouldAutorotate、supportedInterfaceOrientations。</p>
<p>收到旋转事件后的处理，同样在willRotateToInterfaceOrientation和didRotateFromInterfaceOrientation中进行。</p>
<h5 id="三、UISwitch"><a href="#三、UISwitch" class="headerlink" title="三、UISwitch"></a>三、UISwitch</h5><p>ios6下，新增了以下几个属性，可以设置开关的颜色以及背景图。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">@property (nonatomic,  retain) UIColor *tintColor;</div><div class="line"> </div><div class="line">@property (nonatomic,  retain) UIColor *thumbTintColor;</div><div class="line"> </div><div class="line">@property (nonatomic,  retain) UIImage *onImage;</div><div class="line"> </div><div class="line">@property (nonatomic,  retain) UIImage *offImage;</div></pre></td></tr></table></figure>
<h5 id="四、UINavigationBar"><a href="#四、UINavigationBar" class="headerlink" title="四、UINavigationBar"></a>四、UINavigationBar</h5><p>ios6新增了，设置阴影图片的属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">@property (nonatomic, retain) UIImage *shadowImage;</div></pre></td></tr></table></figure>
<h5 id="五、UIImage"><a href="#五、UIImage" class="headerlink" title="五、UIImage"></a>五、UIImage</h5><p>可以在ios6下设置图片的scale比例尺寸了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">+ (UIImage *)imageWithData:(NSData *)data scale:(CGFloat)scale;</div><div class="line"> </div><div class="line">- (id)initWithData:(NSData *)data scale:(CGFloat)scale;</div></pre></td></tr></table></figure>
<h5 id="六、UIRefreshControl"><a href="#六、UIRefreshControl" class="headerlink" title="六、UIRefreshControl"></a>六、UIRefreshControl</h5><p>之前苹果官方是没有现成的下拉刷新的控件，都是自己实现或者使用比较成熟的开源库。</p>
<p>ios6苹果加入了UIRefreshControl，配合UITableView直接实现下拉刷新。</p>
<h5 id="七、UICollectionView"><a href="#七、UICollectionView" class="headerlink" title="七、UICollectionView"></a>七、UICollectionView</h5><p>全新的集合控件，应用场景有类似照片墙，瀑布流等。</p>
<h1 id="iOS7新特性"><a href="#iOS7新特性" class="headerlink" title="iOS7新特性"></a>iOS7新特性</h1><hr>
<h5 id="一、已禁用-UIDevice-uniqueIdentifier"><a href="#一、已禁用-UIDevice-uniqueIdentifier" class="headerlink" title="一、已禁用-[UIDevice uniqueIdentifier]"></a>一、已禁用-[UIDevice uniqueIdentifier]</h5><p>苹果总是把用户的隐私看的很重要。-[UIDevice uniqueIdentifier]在iOS5实际在iOS5的时候已经被遗弃了，但是iOS7中已经完全的禁用了它。Xcode5甚至不会允许你编译包含了指引到-[UIDevice uniqueIdentifier]的app。</p>
<p>此外，iOS7之前的使用了-[UIDevice uniqueIdentifier] 的app如果在iOS7上运行，它不会返回设备的UUID，而是会返回一串字符串，以FFFFFFFF开头，跟着-[UIDevice identifierForVendor]的十六进制值。</p>
<h5 id="二、UIPasteboard由共享变为沙盒化了"><a href="#二、UIPasteboard由共享变为沙盒化了" class="headerlink" title="二、UIPasteboard由共享变为沙盒化了"></a>二、UIPasteboard由共享变为沙盒化了</h5><p>UIPasteboard过去是用来做app之间的数据分享的。UIPasteboard本无问题，但是开发者开始使用它来存储标识符，和其他的相关app分享这些标识符的时候问题就出现了。有一个使用这种把戏的就是OpenUDID。</p>
<p>在iOS7中，使用 +[UIPasteboard pasteboardWithName:create:]和 +[UIPasteboard pasteboardWithUniqueName]创建剪贴板，而且只对相同的app group可见，这样就让OpenUDID不那么有用了。</p>
<h5 id="三、MAC地址不能再用来设别设备"><a href="#三、MAC地址不能再用来设别设备" class="headerlink" title="三、MAC地址不能再用来设别设备"></a>三、MAC地址不能再用来设别设备</h5><p>还有一个生成iOS设备唯一标示符的方法是使用iOS设备的Media Access Control（MAC）地址。一个MAC地址是一个唯一的号码，它是物理网络层级方面分配给网络适配器的。这个地址苹果还有其他的名字，比如说是硬件地址（Hardware Address)或是Wifi地址，都是指同样的东西。</p>
<p>有很多工程和框架都使用这个方法来生成唯一的设备ID。比如说ODIN。然而，苹果并不希望有人通过MAC地址来分辨用户，所以如果你在iOS7系统上查询MAC地址，它现在只会返回02:00:00:00:00:00。</p>
<p>现在苹果明确的表明你应该使用-[UIDevice identifierForVendor]或是-[ASIdentifierManager advertisingIdentifier]来作为你框架和应用的唯一标示符。坦白的来说，应对这些变化也不是那么的难，见以下代码片段：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">NSString *identifierForVendor = [[UIDevice currentDevice].identifierForVendor UUIDString];</div><div class="line"> </div><div class="line">NSString *identifierForAdvertising = [[ASIdentifierManager sharedManager].advertisingIdentifier UUIDString];</div></pre></td></tr></table></figure>
<p>每种方法都适配一种特别的用法：</p>
<p>identifierForVendor对供应商来说是唯一的一个值，也就是说，由同一个公司发行的的app在相同的设备上运行的时候都会有这个相同的标识符。然而，如果用户删除了这个供应商的app然后再重新安装的话，这个标识符就会不一致。</p>
<p>advertisingIdentifier会返回给在这个设备上所有软件供应商相同的 一个值，所以只能在广告的时候使用。这个值会因为很多情况而有所变化，比如说用户初始化设备的时候便会改变。</p>
<h5 id="四、iOS现在要求app如需使用麦克风，需要征得用户同意"><a href="#四、iOS现在要求app如需使用麦克风，需要征得用户同意" class="headerlink" title="四、iOS现在要求app如需使用麦克风，需要征得用户同意"></a>四、iOS现在要求app如需使用麦克风，需要征得用户同意</h5><p>以前如果app需要使用用户的位置，通讯录，日历，提醒以及照片，接受推送消息，使用用户的社交网络的时候需要征得用户的同意。现在在iOS7当中，使用麦克风也需要取得用户同意了。如果用户不允许app使用麦克风的话，那么需要使用麦克风的app就不能接收不到任何声音。</p>
<p>以下的代码是用来查询用户是否允许app使用麦克风：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">//第一次调用这个方法的时候，系统会提示用户让他同意你的app获取麦克风的数据</div><div class="line">// 其他时候调用方法的时候，则不会提醒用户</div><div class="line">// 而会传递之前的值来要求用户同意</div><div class="line">[[AVAudioSession sharedInstance] requestRecordPermission:^(BOOL granted) &#123;</div><div class="line">    if (granted) &#123;</div><div class="line">        // 用户同意获取数据</div><div class="line">    &#125; else &#123;</div><div class="line">        // 可以显示一个提示框告诉用户这个app没有得到允许？</div><div class="line">    &#125;</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<p>你同时还要注意，如果你在获得用户的同意之前使用任何方法来使用麦克风的话，会引起iOS系统弹出以下警示栏：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1115674-bbbee5afa7d69be2.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="4673_140117110443_1.jpg"></p>
<h5 id="五、-NSArray-firstObject-的实现"><a href="#五、-NSArray-firstObject-的实现" class="headerlink" title="五、[NSArray firstObject]的实现"></a>五、[NSArray firstObject]的实现</h5><p><code>-[NSArray firstObject]可能是Objective-C中被调用做多的API。在Open Radar上一个简单的调查显示有一些需求苹果已经做了记录。好消息是现在这些需求已经得到了解决。. firstObject的使用可以追溯到iOS4.0，但是那时仅仅是一个私有方法。在iOS7以前，工程师用下面的方式来使用它：</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">NSArray *arr = @[];</div><div class="line">id item = [arr firstObject];</div><div class="line"></div><div class="line">// 在之前你需要做以下工作</div><div class="line">id item = [arr count] &gt; 0 ? arr[0] : nil;</div></pre></td></tr></table></figure>
<p>因为上面的方式很平常，有些人将它作为一个类增加到NSArray中，然后创建他们自己的firstObject方法。</p>
<p>这个方法的问题是这个方法的名字必须是唯一的，否则的话这个方法所引发的问题无法预估。</p>
<p>请确保检查你是否有任何自定义的代码在NSArray上实现了firstObject，如果有的话看看它是否是必须的，不是必须的话就把它全部移除。</p>
<h5 id="六、增加了instancetype"><a href="#六、增加了instancetype" class="headerlink" title="六、增加了instancetype"></a>六、增加了instancetype</h5><p>instancetype让iOS7API变得更加难懂。苹果改变了大部分 initializer和简易构造函数（convenience constructors），用instancetype代替id作返回类型。但是这个instancetype是什么呢？</p>
<p>instancetype用来在声明一个方法时告诉编译器其返回类型，它表示返回调用该方法的类的对象。</p>
<p>这比之前返回id的通常做法要好，编译器可以对返回类型做一些检查，如果出现错误，在编译时就能提醒你，而不是在程序运行时发生崩溃。</p>
<p>同时，在调用子类方法时，使用它还可以省去对返回值的强制类型转换，编译器能够正确推断方法的返回值类型。</p>
<p>要说到instancetaype的缺点和优点吗？基本上，在任何可能的情况下都可以使用它。</p>
<h5 id="七、设置UIImage的渲染模式：UIImage-renderingMode"><a href="#七、设置UIImage的渲染模式：UIImage-renderingMode" class="headerlink" title="七、设置UIImage的渲染模式：UIImage.renderingMode"></a>七、设置UIImage的渲染模式：UIImage.renderingMode</h5><p>着色（Tint Color）是iOS7界面中的一个重大改变，你可以设置一个UIImage在渲染时是否使用当前视图的Tint Color。</p>
<p>UIImage新增了一个只读属性：renderingMode，对应的还有一个新增方法：imageWithRenderingMode:，它使用UIImageRenderingMode枚举值来设置图片的renderingMode属性。该枚举中包含下列值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">// 根据图片的使用环境和所处的绘图上下文自动调整渲染模式</div><div class="line">UIImageRenderingModeAutomatic </div><div class="line"> </div><div class="line">// 始终绘制图片原始状态，不使用Tint Color</div><div class="line">UIImageRenderingModeAlwaysOriginal </div><div class="line"> </div><div class="line">// 始终根据Tint Color绘制图片，忽略图片的颜色信息</div><div class="line">UIImageRenderingModeAlwaysTemplate</div></pre></td></tr></table></figure>
<p>renderingMode属性的默认值是UIImageRenderingModeAutomatic，即UIImage是否使用Tint Color取决于它显示的位置。其他情况可以看下面的图例：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1115674-149a58d6122ad36d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="2.png"></p>
<p>以下的代码说明了使用一个既定的rendering模式创建图片是多么简单：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">UIImage *img = [UIImage imageNamed:@&quot;myimage&quot;];</div><div class="line"> </div><div class="line">img = [img imageWithRenderingMode:UIImageRenderingModeAlwaysTemplate];</div></pre></td></tr></table></figure>
<h5 id="八、tintcolor-VS-barTintColor"><a href="#八、tintcolor-VS-barTintColor" class="headerlink" title="八、tintcolor VS barTintColor"></a>八、tintcolor VS barTintColor</h5><p>iOS7中你可以使用一个给定的颜色，甚至是记入颜色主题来给整个app着色，帮助你的app脱颖而出。设置app的tint color很简答，只要使用UIView的新属性tintColor即可。</p>
<p>这个属性是否听上去很熟悉呢？应该很熟悉，有些类，比如说UINaviagtionBar，UISearchBar，UITabBar以及UIToolbar已经有了这么命名的属性。他们现在有了一个新的属性：barTintColor。</p>
<p>为了避免使用新属性的时候犯错误，如果你的appp需要支持iOS6以前的系统的时候，请检查一下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">UINavigationBar *bar = self.navigationController.navigationBar;</div><div class="line">UIColor *color = [UIColor greenColor];</div><div class="line"> </div><div class="line">if ([bar respondsToSelector:@selector(setBarTintColor:)]) &#123; // iOS 7+</div><div class="line">    bar.barTintColor = color;</div><div class="line">&#125; else &#123; // what year is this? 2012?</div><div class="line">    bar.tintColor = color;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="九、去掉了纹理颜色"><a href="#九、去掉了纹理颜色" class="headerlink" title="九、去掉了纹理颜色"></a>九、去掉了纹理颜色</h5><p><img src="http://upload-images.jianshu.io/upload_images/1115674-19b99d5124647776.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>纹理颜色？对，不再使用他们了，不能再创建可以展现纹理的颜色。</p>
<p>根据UIInterface.h文件中的注释，-[UIColor groupTableViewBackgroundColor]应该是要在iOS6当中即被删除了，但是它仅仅只是不像之前那样返回纹理颜色了。然而，以下的颜色在iOS7当中被删除了:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">+ (UIColor *)viewFlipsideBackgroundColor;</div><div class="line"> </div><div class="line">+ (UIColor *)scrollViewTexturedBackgroundColor;</div><div class="line"> </div><div class="line">+ (UIColor *)underPageBackgroundColor;</div></pre></td></tr></table></figure>
<h5 id="十、UIButtonTypeRoundRect被UIButtonTypeSystem取代了"><a href="#十、UIButtonTypeRoundRect被UIButtonTypeSystem取代了" class="headerlink" title="十、UIButtonTypeRoundRect被UIButtonTypeSystem取代了"></a>十、UIButtonTypeRoundRect被UIButtonTypeSystem取代了</h5><p><img src="http://upload-images.jianshu.io/upload_images/1115674-a6e3528bf458015d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="4.jpg"></p>
<p>在iOS开发刚开始就陪伴着你的老朋友现在也被删除了，它就是UIButtonTypeRoundRect ，被新的UIButtonTypeSystem取代了。</p>
<p>如果每次iOS系统的发布都没有一些新的功能会是什么样子？这些新功能相信大部分开发者已经知道了，你可能会发现一些新颖的方式将它们整合到你的app中去！</p>
<h5 id="十一、检查无线路由是否可用"><a href="#十一、检查无线路由是否可用" class="headerlink" title="十一、检查无线路由是否可用"></a>十一、检查无线路由是否可用</h5><p>定制一个视频播放器的能力在iOS版本每次的发布中一直有所进步。比如说，在iOS6之前，你不能在MPVolumeView中改变AirPlay的icon。</p>
<p>在iOS7当中，你可以通过AirPlay，蓝牙或是其他的虚线机制了解是否有一个远程的设备可用。了解它的话，就可以让你的app在恰当的时候做恰当的事，比如说，在没有远程设备的时候就不显示AirPlay的icon。</p>
<p>以下是新增加到MPVolumeView的新属性和推送</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">@property (nonatomic, readonly) BOOL wirelessRoutesAvailable; //  是否有设备可以连接的无线线路？</div><div class="line">@property (nonatomic, readonly) BOOL wirelessRouteActive; // 设备现在是否连接上了网络</div><div class="line">NSString *const MPVolumeViewWirelessRoutesAvailableDidChangeNotification;</div><div class="line">NSString *const MPVolumeViewWirelessRouteActiveDidChangeNotification;</div></pre></td></tr></table></figure>
<h5 id="十二、了解蜂窝网络"><a href="#十二、了解蜂窝网络" class="headerlink" title="十二、了解蜂窝网络"></a>十二、了解蜂窝网络</h5><p>在iOS7之前，是使用Reachability来检测设备是否连接到WWAN或是Wifi的。iOS7在这个基础上更进了一步，它会告诉你的设备连接上的是那种蜂窝网络，比如说是Edge网络，HSDPA网络，或是LTE网络。告诉用户他们连接上的是哪种网络可以优化用户体验，因为这样他们会知道网速如何，不会去请求需要高网速的网络请求。</p>
<p>这是CTTelephonyNetworkInfo的部分功能，它是CoreTelephony框架的一部分。iOS7还增加了currentRadioAccessTechnology属性和CTRadioAccessTechnologyDidChangeNotification到这个类。还有一些新的字符串常量来定义可能的值，比如说是CTRadioAccessTechnologyLTE。</p>
<p>以下代码告诉你在app delegate中如何使用这个新功能：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">@import CoreTelephony.CTTelephonyNetworkInfo; // new modules syntax!</div><div class="line">@interface AppDelegate ()</div><div class="line">// we need to keep a reference to the CTTelephonyNetworkInfo object, otherwise the notifications won&apos;t be fired!</div><div class="line">@property (nonatomic, strong) CTTelephonyNetworkInfo *networkInfo;</div><div class="line">@end</div><div class="line"> </div><div class="line">@implementation ViewController</div><div class="line"> </div><div class="line">- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123;</div><div class="line">    // whatever stuff your method does...</div><div class="line">    </div><div class="line">    self.networkInfo = [[CTTelephonyNetworkInfo alloc] init];</div><div class="line">    NSLog(@&quot;Initial cell connection: %@&quot;, self.networkInfo.currentRadioAccessTechnology);</div><div class="line">    [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(radioAccessChanged) name:</div><div class="line">     CTRadioAccessTechnologyDidChangeNotification object:nil];</div><div class="line">    </div><div class="line">    // whatever stuff your method does...</div><div class="line">&#125;</div><div class="line"> </div><div class="line">- (void)radioAccessChanged &#123;</div><div class="line">    NSLog(@&quot;Now you&apos;re connected via %@&quot;, self.networkInfo.currentRadioAccessTechnology);</div><div class="line">&#125;</div><div class="line"> </div><div class="line">@end</div></pre></td></tr></table></figure>
<p>注意：研究一下CTTelephonyNetworkInfo.h 文件来看看是否有其他无线网络类型的的字符串常量。如果设备没有连上的话，currentRadioAccessTechnology 则会返回nil。</p>
<h5 id="十三、通过iCloud同步用户设备的密码"><a href="#十三、通过iCloud同步用户设备的密码" class="headerlink" title="十三、通过iCloud同步用户设备的密码"></a>十三、通过iCloud同步用户设备的密码</h5><p>iOS7以及Mavericks增加了iCloud Keychain来提供密码，以及iCloud中一些敏感数据的同步。开发者可以通过keychain中的kSecAttrSynchronizable key来遍历dictionary对象。</p>
<p>由于直接处理keychain比较难，封装库提供了一个简单的处理keychain的方法。SSKeychain封装库可能是最有名的的一个，作为一种福利，现在它支持在iCloud同步。</p>
<p>以下代码片段显示了如何使用SSKeychain：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">#import &lt;SSKeychain.h&gt;</div><div class="line"> </div><div class="line">- (BOOL)saveCredentials:(NSError **)error &#123;</div><div class="line">    SSKeychainQuery *query = [[SSKeychainQuery alloc] init];</div><div class="line">    query.password = @&quot;MySecretPassword&quot;;</div><div class="line">    query.service = @&quot;MyAwesomeService&quot;;</div><div class="line">    query.account = @&quot;John Doe&quot;;</div><div class="line">    query.synchronizable = YES;</div><div class="line">    return [query save:&amp;error];</div><div class="line">&#125;</div><div class="line"> </div><div class="line">- (NSString *)savedPassword:(NSError **)error &#123;</div><div class="line">    SSKeychainQuery *query = [[SSKeychainQuery alloc] init];</div><div class="line">    query.service = @&quot;MyAwesomeService&quot;;</div><div class="line">    query.account = @&quot;John Doe&quot;;</div><div class="line">    query.synchronizable = YES;</div><div class="line">    query.password = nil;</div><div class="line">    if ([query fetch:&amp;error]) &#123;</div><div class="line">        return query.password;</div><div class="line">    &#125;</div><div class="line">    return nil;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>不要忘记CocoaPods是快速便捷安装SSKeychian的好方法。</p>
<h5 id="十四、使用NSAttributedString显示HTML"><a href="#十四、使用NSAttributedString显示HTML" class="headerlink" title="十四、使用NSAttributedString显示HTML"></a>十四、使用NSAttributedString显示HTML</h5><p>在app中使用webview有时会让人非常沮丧，即使只是显示少量的HTMLneirong ,webview也会消耗大量的内存。现在iOS7让这些变得简单了，你可以从用少量代码在HTML文件中创建一个NSAttributedString，比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">NSString *html = @&quot;&lt;bold&gt;Wow!&lt;/bold&gt; Now &lt;em&gt;iOS&lt;/em&gt; can create &lt;h3&gt;NSAttributedString&lt;/h3&gt; from HTMLs!&quot;;</div><div class="line">NSDictionary *options = @&#123;NSDocumentTypeDocumentAttribute: NSHTMLTextDocumentType&#125;;</div><div class="line"> </div><div class="line">NSAttributedString *attrString = [[NSAttributedString alloc] initWithData:[html dataUsingEncoding:NSUTF8StringEncoding] options:options documentAttributes:nil error:nil];</div></pre></td></tr></table></figure>
<p>现在你可以在任意的UIKit对象上使用NSAttributedString 了，比如说是一个UILabel或是一个UITextField。</p>
<p>注意：NSHTMLTextDocumentType 只是NSDocumentTypeDocumentAttribute key一种可能的值。你还可以使用NSPlainTextDocumentType，NSRTFTextDocumentType或是NSRTFDTextDocumentType。</p>
<p>你还可以从NSAttributedString中创建一个HTML字符串，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">NSAttributedString *attrString; // from previous code</div><div class="line">NSDictionary *options = @&#123;NSDocumentTypeDocumentAttribute: NSHTMLTextDocumentType&#125;;</div><div class="line"> </div><div class="line">NSData *htmlData = [attrString dataFromRange:NSMakeRange(0, [attrString length]) documentAttributes:options error:nil];</div><div class="line">NSString *htmlString = [[NSString alloc] initWithData:htmlData encoding:NSUTF8StringEncoding];</div></pre></td></tr></table></figure>
<p>现在你估计在app中会更多的使用HTML了。</p>
<h5 id="十五、使用原生的Base64"><a href="#十五、使用原生的Base64" class="headerlink" title="十五、使用原生的Base64"></a>十五、使用原生的Base64</h5><p>Base64是使用ASCII码显示二进制数据的一种流行方法。直到现在，开发者还不得不使用开源的工具来编码解码Base64的内容。</p>
<p>现在iOS7引入了以下四种新的NSData方法来操作Base64编码的数据：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">// From NSData.h</div><div class="line">- (id)initWithBase64EncodedString:(NSString *)base64String options:(NSDataBase64DecodingOptions)options;</div><div class="line"> </div><div class="line">- (NSString *)base64EncodedStringWithOptions:(NSDataBase64EncodingOptions)options;</div><div class="line"> </div><div class="line">- (id)initWithBase64EncodedData:(NSData *)base64Data options:(NSDataBase64DecodingOptions)options;</div><div class="line"> </div><div class="line">- (NSData *)base64EncodedDataWithOptions:(NSDataBase64EncodingOptions)options;</div></pre></td></tr></table></figure>
<p>这些方法可以帮助你轻易的将NSData对象转化为Base64，或者将Base64转化为NSData object。见以下的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">NSData* sampleData = [@&quot;Some sample data&quot; dataUsingEncoding:NSUTF8StringEncoding];</div><div class="line"> </div><div class="line">NSString * base64String = [sampleData base64EncodedStringWithOptions:0];</div><div class="line">NSLog(@&quot;Base64-encoded string is %@&quot;, base64String); // prints &quot;U29tZSBzYW1wbGUgZGF0YQ==&quot;</div><div class="line"> </div><div class="line">NSData* dataFromString = [[NSData alloc] initWithBase64EncodedString:base64String options:0];</div><div class="line">NSLog(@&quot;String is %@&quot;,[NSString stringWithUTF8String:[dataFromString bytes]]); // prints &quot;String is Some sample data&quot;</div></pre></td></tr></table></figure>
<p>如果你需要支持iOS6或者更早以前的系统，你可以使用以下两个方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">/* These methods first appeared in NSData.h on OS X 10.9 and iOS 7.0. They are deprecated in the same releases in favor of</div><div class="line"> the methods in the &lt;code&gt;NSDataBase64Encoding&lt;/code&gt; category. However, these methods have existed for several releases, so</div><div class="line"> they may be used for applications targeting releases prior to OS X 10.9 and iOS 7.0.</div><div class="line"> */</div><div class="line">- (id)initWithBase64Encoding:(NSString *)base64String;</div><div class="line">- (NSString *)base64Encoding;</div></pre></td></tr></table></figure>
<h5 id="十六、使用UIApplicationUserDidTakeScreenshotNotification来检查截图"><a href="#十六、使用UIApplicationUserDidTakeScreenshotNotification来检查截图" class="headerlink" title="十六、使用UIApplicationUserDidTakeScreenshotNotification来检查截图"></a>十六、使用UIApplicationUserDidTakeScreenshotNotification来检查截图</h5><p>在iOS7之前，像Snapshot或是Facebook Poke这样的app是使用一些很精巧的方法来检测用户是否有截图。然而，iOS7提供一个崭新的推送方法：UIApplicationUserDidTakeScreenshotNotification。只要像往常一样订阅即可知道什么时候截图了。</p>
<p>注意：UIApplicationUserDidTakeScreenshotNotification 将会在截图完成之后显示。现在在截图截取之前无法得到通知。希望苹果会在iOS8当中增加UIApplicationUserWillTakeScreenshotNotification。</p>
<h5 id="十七、实现多语言语音合成"><a href="#十七、实现多语言语音合成" class="headerlink" title="十七、实现多语言语音合成"></a>十七、实现多语言语音合成</h5><p>如果可以让app说话会不会很好呢？iOS7加入了两个新类：AVSpeechSynthesizer 以及AVSpeechUtterance。这两个类可以给你的app发声。很有意思不是吗？有多种语言可供选择——Siri不会说的语言也有，比如说巴西葡萄牙语。</p>
<p>使用这两个类给app提供语言合成的功能非常简单。AVSpeechUtterance 代表你想说什么，如何说。AVSpeechSynthesizer 用来发出这些声音，见以下代码片段：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">AVSpeechSynthesizer *synthesizer = [[AVSpeechSynthesizer alloc] init];</div><div class="line">AVSpeechUtterance *utterance =</div><div class="line">[AVSpeechUtterance speechUtteranceWithString:@&quot;Wow, I have such a nice voice!&quot;];</div><div class="line">utterance.rate = AVSpeechUtteranceMaximumSpeechRate / 4.0f;</div><div class="line">utterance.voice = [AVSpeechSynthesisVoice voiceWithLanguage:@&quot;en-US&quot;]; // defaults to your system language</div><div class="line">[synthesizer speakUtterance:utterance];</div></pre></td></tr></table></figure>
<h5 id="十八、使用了新的UIScreenEdgePanGestureRecognizer"><a href="#十八、使用了新的UIScreenEdgePanGestureRecognizer" class="headerlink" title="十八、使用了新的UIScreenEdgePanGestureRecognizer"></a>十八、使用了新的UIScreenEdgePanGestureRecognizer</h5><p>UIScreenEdgePanGestureRecognizer 继承自UIPanGestureRecognizer ，它可以让你从屏幕边界即可检测手势。</p>
<p>使用新的手势识别器很简单，见以下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">UIScreenEdgePanGestureRecognizer *recognizer = [[UIScreenEdgePanGestureRecognizer alloc] initWithTarget:self action:@selector(handleScreenEdgeRecognizer:)];</div><div class="line">recognizer.edges = UIRectEdgeLeft;</div><div class="line">[self.view addGestureRecognizer:recognizer];</div></pre></td></tr></table></figure>
<h5 id="十九、使用UIScrollViewKeyboardDismissMode实现了Message-app的行为"><a href="#十九、使用UIScrollViewKeyboardDismissMode实现了Message-app的行为" class="headerlink" title="十九、使用UIScrollViewKeyboardDismissMode实现了Message app的行为"></a>十九、使用UIScrollViewKeyboardDismissMode实现了Message app的行为</h5><p>像Messages app一样在滚动的时候可以让键盘消失是一种非常好的体验。然而，将这种行为整合到你的app很难。幸运的是，苹果给UIScrollView添加了一个很好用的属性keyboardDismissMode，这样可以方便很多。</p>
<p>现在仅仅只需要在Storyboard中改变一个简单的属性，或者增加一行代码，你的app可以和办到和Messages app一样的事情了。</p>
<p>这个属性使用了新的UIScrollViewKeyboardDismissMode enum枚举类型。这个enum枚举类型可能的值如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">UIScrollViewKeyboardDismissModeNone        // the keyboard is not dismissed automatically when scrolling</div><div class="line">UIScrollViewKeyboardDismissModeOnDrag      // dismisses the keyboard when a drag begins</div><div class="line">UIScrollViewKeyboardDismissModeInteractive // the keyboard follows the dragging touch off screen, and may be</div><div class="line">pulled upward again to cancel the dismiss</div></pre></td></tr></table></figure>
<p>以下是让键盘可以在滚动的时候消失需要设置的属性：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1115674-abd959abacad82b7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="5.png"></p>
<h5 id="二十、使用Core-Image来检测眨眼以及微笑"><a href="#二十、使用Core-Image来检测眨眼以及微笑" class="headerlink" title="二十、使用Core Image来检测眨眼以及微笑"></a>二十、使用Core Image来检测眨眼以及微笑</h5><p>iOS给Core Image增加了两种人脸检测功能：CIDetectorEyeBlink以及CIDetectorSmile。这也就是说你现在可以在照片中检测微笑以及眨眼。</p>
<p>以下是在app中使用它的方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">UIImage *image = [UIImage imageNamed:@&quot;myImage&quot;];</div><div class="line">CIDetector *detector = [CIDetector detectorOfType:CIDetectorTypeFace</div><div class="line">                                          context:nil</div><div class="line">                                          options:@&#123;CIDetectorAccuracy: CIDetectorAccuracyHigh&#125;];</div><div class="line"> </div><div class="line">NSDictionary *options = @&#123; CIDetectorSmile: @YES, CIDetectorEyeBlink: @YES &#125;;</div><div class="line"> </div><div class="line">NSArray *features = [detector featuresInImage:image.CIImage options:options];</div><div class="line"> </div><div class="line">for (CIFaceFeature *feature in features) &#123;</div><div class="line">    NSLog(@&quot;Bounds: %@&quot;, NSStringFromCGRect(feature.bounds));</div><div class="line">    </div><div class="line">    if (feature.hasSmile) &#123;</div><div class="line">        NSLog(@&quot;Nice smile!&quot;);</div><div class="line">    &#125; else &#123;</div><div class="line">        NSLog(@&quot;Why so serious?&quot;);</div><div class="line">    &#125;</div><div class="line">    if (feature.leftEyeClosed || feature.rightEyeClosed) &#123;</div><div class="line">        NSLog(@&quot;Open your eyes!&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="二十一、给UITextView增加了链接"><a href="#二十一、给UITextView增加了链接" class="headerlink" title="二十一、给UITextView增加了链接"></a>二十一、给UITextView增加了链接</h5><p>现在在iOS添加你自己的Twitter账户更加简单了，现在你可以给一个NSAttributedString增加链接了，然后当它被点击的时候唤起一个定制的action。</p>
<p>首先，创建一个NSAttributedString然后增加给它增加一个NSLinkAttributeName 属性，见以下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">NSMutableAttributedString *attributedString = [[NSMutableAttributedString alloc] initWithString:@&quot;This is an example by @marcelofabri_&quot;];</div><div class="line">[attributedString addAttribute:NSLinkAttributeName</div><div class="line">                         value:@&quot;username://marcelofabri_&quot;</div><div class="line">                         range:[[attributedString string] rangeOfString:@&quot;@marcelofabri_&quot;]];</div><div class="line"> </div><div class="line"> </div><div class="line">NSDictionary *linkAttributes = @&#123;NSForegroundColorAttributeName: [UIColor greenColor],</div><div class="line">                                 NSUnderlineColorAttributeName: [UIColor lightGrayColor],</div><div class="line">                                 NSUnderlineStyleAttributeName: @(NSUnderlinePatternSolid)&#125;;</div><div class="line"> </div><div class="line">// assume that textView is a UITextView previously created (either by code or Interface Builder)</div><div class="line">textView.linkTextAttributes = linkAttributes; // customizes the appearance of links</div><div class="line">textView.attributedText = attributedString;</div><div class="line">textView.delegate = self;</div></pre></td></tr></table></figure>
<p>这样就可以让链接在文本中显示。然而，你也可以控制当链接被点击的时候会发生什么，实现这个可以使用UITextViewDelegate协议的新的shouldInteractWithURL方法，就像这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">- (BOOL)textView:(UITextView *)textView shouldInteractWithURL:(NSURL *)URL inRange:(NSRange)characterRange &#123;</div><div class="line">    if ([[URL scheme] isEqualToString:@&quot;username&quot;]) &#123;</div><div class="line">        NSString *username = [URL host];</div><div class="line">        // do something with this username</div><div class="line">        // ...</div><div class="line">        return NO;</div><div class="line">    &#125;</div><div class="line">    return YES; // let the system open this URL</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="iOS8新特性"><a href="#iOS8新特性" class="headerlink" title="iOS8新特性"></a>iOS8新特性</h1><hr>
<h5 id="一、UIAlertController对alert-amp-actionSheet的封装"><a href="#一、UIAlertController对alert-amp-actionSheet的封装" class="headerlink" title="一、UIAlertController对alert&amp;actionSheet的封装"></a>一、UIAlertController对alert&amp;actionSheet的封装</h5><p>UIAlertController.h</p>
<p>提示框按钮的选择<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">typedef NS_ENUM(NSInteger, UIAlertActionStyle) &#123;</div><div class="line">    </div><div class="line">    UIAlertActionStyleDefault = 0,</div><div class="line">    </div><div class="line">    UIAlertActionStyleCancel,</div><div class="line">    </div><div class="line">    UIAlertActionStyleDestructive</div><div class="line">    </div><div class="line">&#125; NS_ENUM_AVAILABLE_IOS(8_0);</div></pre></td></tr></table></figure></p>
<p>提示框的样式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">typedef NS_ENUM(NSInteger, UIAlertControllerStyle) &#123;</div><div class="line">    </div><div class="line">    UIAlertControllerStyleActionSheet = 0,</div><div class="line">    </div><div class="line">    UIAlertControllerStyleAlert</div><div class="line">    </div><div class="line">&#125; NS_ENUM_AVAILABLE_IOS(8_0);</div><div class="line"> </div><div class="line">NS_CLASS_AVAILABLE_IOS(8_0) @interface UIAlertAction : NSObject &lt;NSCopying&gt;</div></pre></td></tr></table></figure>
<p>创建提示框按钮</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">+ (instancetype)actionWithTitle:(NSString *)title style:(UIAlertActionStyle)style handler:(void (^)(UIAlertAction *action))handler;</div><div class="line"> </div><div class="line">@property (nonatomic, readonly) NSString *title;</div><div class="line"> </div><div class="line">@property (nonatomic, readonly) UIAlertActionStyle style;</div><div class="line"> </div><div class="line">@property (nonatomic, getter=isEnabled) BOOL enabled;</div><div class="line"> </div><div class="line">@end</div><div class="line"> </div><div class="line">NS_CLASS_AVAILABLE_IOS(8_0) @interface UIAlertController : UIViewController</div></pre></td></tr></table></figure>
<p>创建提示框</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">+ (instancetype)alertControllerWithTitle:(NSString *)title message:(NSString *)message preferredStyle:(UIAlertControllerStyle)preferredStyle;</div></pre></td></tr></table></figure>
<p>添加按钮</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">- (void)addAction:(UIAlertAction *)action;</div><div class="line"> </div><div class="line">@property (nonatomic, readonly) NSArray *actions;</div></pre></td></tr></table></figure>
<p>添加文本输入框</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">- (void)addTextFieldWithConfigurationHandler:(void (^)(UITextField *textField))configurationHandler;</div><div class="line"> </div><div class="line">@property (nonatomic, readonly) NSArray *textFields;</div><div class="line"> </div><div class="line">@property (nonatomic, copy) NSString *title;</div><div class="line"> </div><div class="line">@property (nonatomic, copy) NSString *message;</div><div class="line"> </div><div class="line">@property (nonatomic, readonly) UIAlertControllerStyle preferredStyle;</div></pre></td></tr></table></figure>
<p>简单实用示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">// 1.创建提示框对象，默认是actionSheet效果</div><div class="line">UIAlertController *alert = [UIAlertController alertControllerWithTitle:@&quot;注意&quot; message:@&quot;我的呈现方式变了&quot; preferredStyle:UIAlertControllerStyleAlert];</div><div class="line"> </div><div class="line">// 2.创建取消按钮并添加到提示框上</div><div class="line">[alert addAction:[UIAlertAction actionWithTitle:@&quot;取消&quot; style:UIAlertActionStyleCancel handler:^(UIAlertAction *action) &#123;</div><div class="line">    </div><div class="line">    NSLog(@&quot;取消按钮被点击了&quot;);</div><div class="line">&#125;]];</div><div class="line"></div><div class="line">// 3.呈现提示框</div><div class="line">[self presentViewController:alert animated:YES completion:nil];</div></pre></td></tr></table></figure></p>
<h5 id="二、UIPopoverController直接通过present方式呈现"><a href="#二、UIPopoverController直接通过present方式呈现" class="headerlink" title="二、UIPopoverController直接通过present方式呈现"></a>二、UIPopoverController直接通过present方式呈现</h5><p>UIViewController.h</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">typedef NS_ENUM(NSInteger, UIModalPresentationStyle) &#123;</div><div class="line">    </div><div class="line">    UIModalPresentationFullScreen = 0,</div><div class="line">    </div><div class="line">    UIModalPresentationPageSheet NS_ENUM_AVAILABLE_IOS(3_2),</div><div class="line">    </div><div class="line">    UIModalPresentationFormSheet NS_ENUM_AVAILABLE_IOS(3_2),</div><div class="line">    </div><div class="line">    UIModalPresentationCurrentContext NS_ENUM_AVAILABLE_IOS(3_2),</div><div class="line">    </div><div class="line">    UIModalPresentationCustom NS_ENUM_AVAILABLE_IOS(7_0),</div><div class="line">    </div><div class="line">    UIModalPresentationOverFullScreen NS_ENUM_AVAILABLE_IOS(8_0),</div><div class="line">    </div><div class="line">    UIModalPresentationOverCurrentContext NS_ENUM_AVAILABLE_IOS(8_0),</div><div class="line">    </div><div class="line">    UIModalPresentationPopover NS_ENUM_AVAILABLE_IOS(8_0),</div><div class="line">    </div><div class="line">    UIModalPresentationNone NS_ENUM_AVAILABLE_IOS(7_0) = -1,</div><div class="line">    </div><div class="line">&#125;;</div><div class="line"> </div><div class="line">@property (nonatomic,readonly) UIPopoverPresentationController *popoverPresentationController NS_AVAILABLE_IOS(8_0);</div></pre></td></tr></table></figure>
<p>使用示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">// 1.创建内容控制器</div><div class="line">UITableViewController *contentVc = [[UITableViewController alloc] init];</div><div class="line"> </div><div class="line">// 2.1 设置呈现方式</div><div class="line">contentVc.modalPresentationStyle = UIModalPresentationPopover;</div><div class="line"> </div><div class="line">// 2.2设置在导航栏的左边按钮呈现</div><div class="line">contentVc.popoverPresentationController.barButtonItem = self.navigationItem.leftBarButtonItem;</div><div class="line"> </div><div class="line">// 3.呈现</div><div class="line">[self presentViewController:contentVc animated:YES completion:nil];</div></pre></td></tr></table></figure>
<p>以前的方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">// 1.创建内容控制器</div><div class="line">UITableViewController *contentVc = [[UITableViewController alloc] init];</div><div class="line"> </div><div class="line">// 2.创建popover</div><div class="line">UIPopoverController *popover = [[UIPopoverController alloc] initWithContentViewController:contentVc];</div><div class="line"> </div><div class="line">popover.popoverContentSize = CGSizeMake(100, 100);</div><div class="line"> </div><div class="line">// 3.呈现</div><div class="line">[popover presentPopoverFromBarButtonItem:self.navigationItem.leftBarButtonItem permittedArrowDirections:UIPopoverArrowDirectionAny animated:YES];</div></pre></td></tr></table></figure>
<h5 id="三、获取用户授权的用户隐私保护"><a href="#三、获取用户授权的用户隐私保护" class="headerlink" title="三、获取用户授权的用户隐私保护"></a>三、获取用户授权的用户隐私保护</h5><p>地图定位示例 ：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">// 导入定位框架</div><div class="line">#import &lt;CoreLocation/CoreLocation.h&gt;</div><div class="line"> </div><div class="line">@interface ViewController ()&lt;CLLocationManagerDelegate&gt;</div><div class="line"> </div><div class="line">// 设置定位对象</div><div class="line">@property(nonatomic,strong)CLLocationManager* maneger;</div><div class="line"> </div><div class="line">@end</div><div class="line"> </div><div class="line">@implementation ViewController</div><div class="line"> </div><div class="line">- (void)viewDidLoad &#123;</div><div class="line">    [super viewDidLoad];</div><div class="line">    </div><div class="line">    // 当使用iOS8定位的时候需要请求用户授权，且在info.plist里添加字段NSLocationAlwaysUsageDescription 请求用户授权的描述</div><div class="line">    // iOS7仅仅需要在info.plist里添加字段Privacy - Location Usage Description 请求用户授权的描述</div><div class="line">    // 不需要再写下面的代码</div><div class="line">    if (IOS8) &#123;</div><div class="line">        [self.maneger requestAlwaysAuthorization];//请求用户授权 </div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    // 开启定位</div><div class="line">    [self.maneger startUpdatingLocation];</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h5 id="四、针对屏幕适配应运而生的size-classes"><a href="#四、针对屏幕适配应运而生的size-classes" class="headerlink" title="四、针对屏幕适配应运而生的size classes"></a>四、针对屏幕适配应运而生的size classes</h5><p>size classes是为了解决storyboard只能订制一种屏幕样式的问题，它不再是具体的尺寸，而是抽象尺寸通过宽/高 的compact、any、regular 组成了九种组合包含了所有苹果设备的尺寸。</p>
<h1 id="iOS9新特性"><a href="#iOS9新特性" class="headerlink" title="iOS9新特性"></a>iOS9新特性</h1><hr>
<h5 id="一、网络适配"><a href="#一、网络适配" class="headerlink" title="一、网络适配"></a>一、网络适配</h5><p>iOS9系统发送的网络请求将统一使用TLS 1.2 SSL。采用TLS 1.2 协议，目的是强制增强数据访问安全，而且系统Foundation框架下的相关网络请求，将不再默认使用HTTP等不安全的网络协议，而默认采用TLS 1.2。服务器因此需要更新，以解析相关数据。如不更新，可通过在 info.plist 中声明，倒退回不安全的网络请求。</p>
<p>什么是SSL/TLS？跟HTTP和HTTPS有什么关系？</p>
<p>跟往常一样，先说结论：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">HTTP + SSL/TLS + TCP = HTTPS</div></pre></td></tr></table></figure>
<p>TLS 是 SSL 新的别称。举个例子：</p>
<p>“TLS1.0”之于“SSL3.1”，犹“公元2015”之于“民国104”，或者是“一千克”之于“一公斤”，或者是“半斤”之于“八两”：称呼不同，但意思相同。</p>
<p>SSL 3.0版本之后的迭代版本被重新命名为TLS 1.0，也就是说：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">TLS 1.0 ＝ SSL 3.1</div></pre></td></tr></table></figure>
<p>所以他们是一个东西，我们平常也经常简单见到 “SSL/TLS” 这种说法。常用的是下面这些：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">SSL 2.0</div><div class="line"> </div><div class="line">SSL 3.0</div><div class="line"> </div><div class="line">TLS 1.0 (SSL 3.1)</div><div class="line"> </div><div class="line">TLS 1.1 (SSL 3.1)</div><div class="line"> </div><div class="line">TLS 1.2 (SSL 3.1)</div></pre></td></tr></table></figure>
<p>那为什么标题是“使用HTTPS”而没有提及SSL和TLS什么事？ 要理解这个，要看下一个公式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">HTTP + SSL/TLS + TCP = HTTPS</div></pre></td></tr></table></figure>
<p>打个比方：如果原来的 HTTP 是塑料水管，容易被戳破；那么如今新设计的 HTTPS 就像是在原有的塑料水管之外，再包一层金属水管。一来，原有的塑料水管照样运行；二来，用金属加固了之后，不容易被戳破。</p>
<p>目前，应用最广泛的是TLS 1.0，接下来是SSL 3.0。但是，主流浏览器都已经实现了TLS 1.2的支持。Apple让你的HTTP采用SSL/TLS协议，就是让你从HTTP转到HTTPS。</p>
<p>以前的HTTP不是也能用吗？为什么要用SSL/TLS，闲得慌？！Apple是不是又在反人类？</p>
<p>不使用SSL/TLS的HTTP通信，就是不加密的通信！</p>
<p>所有信息明文传播，带来了三大风险：</p>
<p>窃听风险（eavesdropping）：第三方可以获知通信内容。</p>
<p>篡改风险（tampering）：第三方可以修改通信内容。</p>
<p>冒充风险（pretending）：第三方可以冒充他人身份参与通信。</p>
<p>SSL/TLS协议是为了解决这三大风险而设计的，希望达到：</p>
<p>所有信息都是加密传播，第三方无法窃听。</p>
<p>具有校验机制，一旦被篡改，通信双方会立刻发现。</p>
<p>配备身份证书，防止身份被冒充。</p>
<p>如何适配？—弱弱地问下：加班要多久？</p>
<p>正如文章开头所说：</p>
<p>TLS 1.2 协议 强制增强数据访问安全 系统 Foundation 框架下的相关网络请求，将不再默认使用 HTTP 等不安全的网络协议，而默认采用 TLS 1.2。服务器因此需要更新，以解析相关数据。如不更新，可通过在 Info.plist 中声明，倒退回不安全的网络请求。</p>
<p>方案一：立即让公司的服务端升级使用TLS 1.2。</p>
<p>方案二：虽Apple不建议，但可通过在 Info.plist 中声明，倒退回不安全的网络请求依然能让App访问指定http，甚至任意的http。</p>
<p>info.plist 配置中的XML源码如下所示:</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1115674-75a082354660ff99.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="6.jpg"></p>
<p>上面是比较严谨的做法，指定了能访问哪些特定的HTTP。当然也有暴力的做法： 彻底倒退回不安全的HTTP网络请求，能任意进行HTTP请求，比如你在开发一款浏览器App，或者你想偷懒，或者后台想偷懒，或者公司不给你升级服务器。但目前Apple的官方文档并未提及如何在 info.plist 配置可以参考本文：<a href="http://blog.6ag.cn/1065.html" target="_blank" rel="external">http://blog.6ag.cn/1065.html</a></p>
<h5 id="二、更灵活的后台定位"><a href="#二、更灵活的后台定位" class="headerlink" title="二、更灵活的后台定位"></a>二、更灵活的后台定位</h5><p>如果不适配iOS9，就不能偷偷在后台定位。不过苹果将允许出现这种场景：</p>
<p>同一App中的多个location manager，一些只能在前台定位，另一些可在后台定位，并可随时开启或者关闭特定location manager的后台定位。</p>
<p>如何偷偷在后台定位：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">// 1. 实例化定位管理器</div><div class="line">_locationManager = [[CLLocationManager alloc] init];</div><div class="line"> </div><div class="line">// 2. 设置代理</div><div class="line">_locationManager.delegate = self;</div><div class="line"> </div><div class="line">// 3. 定位精度</div><div class="line">[_locationManager setDesiredAccuracy:kCLLocationAccuracyBest];</div><div class="line"> </div><div class="line">// 4.请求用户权限：分为：?只在前台开启定位?在后台也可定位，</div><div class="line">//注意：建议只请求?和?中的一个，如果两个权限都需要，只请求?即可，</div><div class="line">//??这样的顺序，将导致bug：第一次启动程序后，系统将只请求?的权限，?的权限系统不会请求，只会在下一次启动应用时请求?</div><div class="line">if ([[[UIDevice currentDevice] systemVersion] floatValue] &gt;= 8) &#123;</div><div class="line">    //[_locationManager requestWhenInUseAuthorization];//?只在前台开启定位</div><div class="line">    [_locationManager requestAlwaysAuthorization];//?在后台也可定位</div><div class="line">&#125;</div><div class="line"> </div><div class="line">// 5.iOS9新特性：将允许出现这种场景：同一app中多个location manager：一些只能在前台定位，另一些可在后台定位（并可随时禁止其后台定位）。</div><div class="line">if ([[[UIDevice currentDevice] systemVersion] floatValue] &gt;= 9) &#123;</div><div class="line">    _locationManager.allowsBackgroundLocationUpdates = YES;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">// 6. 更新用户位置</div><div class="line">[_locationManager startUpdatingLocation];</div></pre></td></tr></table></figure>
<p>但是如果照着这种方式尝试，而没有配置info.plist，100%你的程序会崩溃掉，并报错：</p>
<p><em>*</em> Assertion failure in -[CLLocationManager setAllowsBackgroundLocationUpdates:], /BuildRoot/Library/Caches/com.apple.xbs/Sources/CoreLocationFramework_Sim/CoreLocation-1808.1.5/Framework/CoreLocation/CLLocationManager.m:593</p>
<p>要将 info.plist 配置如下：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1115674-a031a45dc10b6d47.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="7.png"></p>
<p>对应的 Info.plist 的XML源码是：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1115674-6e80d5e7418c640c.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="8.jpg"></p>
<h5 id="三、Bitcode"><a href="#三、Bitcode" class="headerlink" title="三、Bitcode"></a>三、Bitcode</h5><p>bitcode的理解应该是把程序编译成的一种过渡代码，然后苹果再把这个过渡代码编译成可执行的程序。bitcode也允许苹果在后期重新优化我们程序的二进制文件，有类似于App瘦身的思想。未来Watch应用须包含Bitcode，iOS不强制，但Xcode7默认会开启Bitcode。</p>
<p>用了xcode7的编译器编译之前没问题的项目可能会出现下列报错。</p>
<p>XXXX’ does not contain bitcode. You must rebuild it with bitcode enabled (Xcode setting ENABLE_BITCODE), obtain an updated library from the vendor, or disable bitcode forthistarget. forarchitecture arm64</p>
<p>问题的原因是：某些第三方库还不支持bitcode。要不然是等待库的开发者升级了此项功能我们更新库，要不就是把这个bitcode禁用。禁用Bitcode，方法见下图：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1115674-7ff5bfa5eb57e418.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="9.png"></p>
<h5 id="四、企业级分发"><a href="#四、企业级分发" class="headerlink" title="四、企业级分发"></a>四、企业级分发</h5><p>iOS9之前，企业级分发十分方便：点击App出现“信任按钮”。</p>
<p>iOS9以后，企业级分发ipa包将遭到与Mac上dmg安装包一样的待遇。默认不能安装，也不再出现“信任按钮”，必须让用户进行gif图中的设置。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1115674-9d34f78d3daffa2f.gif?imageMogr2/auto-orient/strip" alt="10.gif"></p>
<h5 id="五、URL-scheme"><a href="#五、URL-scheme" class="headerlink" title="五、URL scheme"></a>五、URL scheme</h5><p>URL scheme一般使用的场景是应用程序有分享或跳其他平台授权的功能，分享或授权后再跳回来。在iOS8并没有做过多限制，在iOS9中，如果使用URL scheme必须在”info.plist”中将你要在外部调用的URL scheme列为白名单，否则不能使用。</p>
<p>canOpenURL: failed forURL : “mqzone://qqapp”- error: “This app is not allowed to query for scheme mqzone”</p>
<p>具体的解决方案也是要在info.plist中设置 LSApplicationQueriesSchemes 类型为数组，下面添加所有你用到的scheme</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1115674-c756c23b4a7d1e69.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="11.png"></p>
<p>推荐一篇博客: <a href="http://awkwardhare.com/post/121196006730/quick-take-on-ios-9-url-scheme-changes" target="_blank" rel="external">http://awkwardhare.com/post/121196006730/quick-take-on-ios-9-url-scheme-changes</a></p>
<p>其中最关键的是以下部分：</p>
<p>If you call the “canOpenURL” method on a URL that is not in your whitelist, it will return “NO”, even if there is an app installed that has registered to handle this scheme. A “This app is not allowed to query for scheme xxx” syslog entry will appear.</p>
<p>If you call the “openURL” method on a URL that is not in your whitelist, it will fail silently. A “This app is not allowed to query for scheme xxx” syslog entry will appear.</p>
<h5 id="六、新字体"><a href="#六、新字体" class="headerlink" title="六、新字体"></a>六、新字体</h5><p>iOS8中，字体是Helvetica，中文的字体有点类似于“华文细黑”。只是苹果手机自带渲染，所以看上去可能比普通的华文细黑要美观。iOS9中，中文系统字体变为了专为中国设计的“苹方” 有点类似于一种word字体“幼圆”。字体有轻微的加粗效果，并且最关键的是字体间隙变大了！</p>
<p>所以很多原本写死了width的label可能会出现“…”的情况。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1115674-c6900be6583fac27.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="12.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1115674-28a5e236ded65e2c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="13.png"></p>
<p>上面这两张图也可以直观的看出同一个界面，同一个label的变化。</p>
<p>所以为了在界面显示上不出错，就算是固定长度的文字也还是建议使用sizetofit 或者ios向上取整 ceilf() 或者提前计算。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">CGSize size = [title sizeWithAttributes:@&#123;NSFontAttributeName: [UIFont systemFontOfSize:14.0f]&#125;];</div><div class="line">CGSize adjustedSize = CGSizeMake(ceilf(size.width), ceilf(size.height));</div></pre></td></tr></table></figure>
<h5 id="七、tableview"><a href="#七、tableview" class="headerlink" title="七、tableview"></a>七、tableview</h5><p>虽然现在的iOS9已经推送正式版了，但是iOS9使用时还是会感觉到App比以前更加卡顿了，tableView拖动时卡顿显示的最为明显。 并且之前遇到一个bug，原本好的项目用xcode7一编译，tableView刷新出了问题 ，[tableView reloadData]无效，有一行cell明明改变了但是刷新不出来。 感觉可能是这个方法和某种新加的特性冲突了，猜测可能是reloadData的操作被推迟到下一个RunLoop执行最终失效。</p>
<p>解决的方法是，注释[tableView reloadData]，改用局部刷新，问题居然就解决了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[self.tableView reloadSections:[NSIndexSet indexSetWithIndex:0] withRowAnimation:UITableViewRowAnimationNone];</div></pre></td></tr></table></figure>
<h5 id="八、iPad适配Slide-Over-和-Split-View"><a href="#八、iPad适配Slide-Over-和-Split-View" class="headerlink" title="八、iPad适配Slide Over 和 Split View"></a>八、iPad适配Slide Over 和 Split View</h5><p>iPad适配Slide Over 和 Split View，若想适配multi tasking特性，唯一的建议：</p>
<p>弃纯代码，改用storyboard、xib，纵观苹果WWDC所有Demo均是如此。</p>
<p>Mysteries of Auto Layout, Part 1<br>What’s New in Storyboards<br>Implementing UI Designs in Interface Builder<br>Getting Started with Multitasking on iPad in iOS 9<br>Optimizing Your App for Multitasking on iPad in iOS</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Coredata]]></title>
      <url>http://jimmypeng.cn/2016/01/11/coredata/</url>
      <content type="html"><![CDATA[<h3 id="一-CoreData-是什么"><a href="#一-CoreData-是什么" class="headerlink" title="一. CoreData 是什么?"></a>一. CoreData 是什么?</h3><ul>
<li>Core Data 是 iOS SDK 里的一个很强大的<strong>框架</strong>,允许程序员以<strong>面向对象的方式储存和管理数据</strong>。使用 Core Data 框架,程序员可以很轻松有效地通过面向对象的接口管理数据</li>
<li><strong>Core Data 是一个模型层的技术</strong>。帮助建立代表程序状态的模型层,Core Data 也是一种 持久化技术,能将模型对象的状态持久化到磁盘,但它最重要的特点是: <strong> Core Data 不仅是一个加载、保存数据的框架,它还能和内存中的数据很好的共事</strong></li>
<li>在数据操作过程中, <strong>无需编写任何SQL语句</strong></li>
<li>Core Data 使用包括<strong>实体</strong>和<strong>实体间</strong>关系,以及查找符合某些条件实体的请求等内容</li>
<li>开发者可以在<strong>纯对象层</strong>上查找与管理这些数据,而不必担心存储和查找的实现细节</li>
<li>Core Data 框架最早出现在 Mac OS X 10.4 Tiger 与 iOS 3.0 系统,经过成千上万的应用程序以及数以百万用户的反复的验证,Core Data 确实已经是一套非常成熟的框架</li>
<li>CoreData利用了Objective-C语言和运行时,巧妙地集成了CoreFoundation框架。是 一个易于使用的框架,不仅可以优雅地<strong>管理对象图</strong>,而且在<strong>内存管理方面表现异常优异</strong></li>
</ul>
<h2 id=""><a href="#" class="headerlink" title=""></a><a id="more"></a></h2><h3 id="二-怎么学习CoreData"><a href="#二-怎么学习CoreData" class="headerlink" title="二. 怎么学习CoreData"></a>二. 怎么学习CoreData</h3><ul>
<li>第一眼看到 Core Data 令人生畏的<strong>复杂</strong>架构关系,很多人都会有无从下手的感觉. </li>
<li>可是, 一旦理解了架构图中各个<strong>部件的组成</strong>及<strong>相互之间的关系</strong>,就能体会到 Core Data API 的简洁和直观了</li>
<li><strong>Core Data stack(堆栈</strong>):如果能够理解 Core Data stack 中的<strong>各个成员所扮演的角色</strong>,那么再使用Core Data 就不会感觉到困难了</li>
<li>误区:<strong>Core Data 不是一个数据库,不要用数据库的眼光去看待 Core Data</strong></li>
<li>Core Data 不是应用程序的数据库,也不是将数据持久化保存到数据库的 API。<strong>Core Data 是一个用于管理对象图的框架</strong>。Core Data 可以把<strong>对象图写入磁盘</strong>从而持久化保存,但是这不是框架的主要目标.</li>
</ul>
<hr>
<h3 id="三-Core-Data-stack"><a href="#三-Core-Data-stack" class="headerlink" title="三. Core Data stack"></a>三. Core Data stack</h3><p>Core Data stack 是 Core Data 的核心,由一组 Core Data 核心对象组成</p>
<ul>
<li><strong>NSManagedObjectContext</strong> 对象管理上下文: 负责管理模型的对象的集合</li>
<li><strong>NSManagedObjectModel</strong> 被管理的对象模型: 负责管理对象模型</li>
<li><strong>NSPersistentStoreCoordinator</strong> 存储调度器: 负责将数据保存到磁盘的</li>
</ul>
<p>三者之间关系示意图:</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1115674-3cebf6f0c3b5e52f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="关系图"></p>
<p>分为两部分:</p>
<ul>
<li>对象图管理</li>
<li>数据持久化<br>在这两部分的中间,即堆栈中间,是持久化存储协调器(Persistent Store Coordinator, PSC)。通过它将对象图管理部分和持久化部分绑在一起。当这两部分中的一部分需要和另一部分交互,将通过 PSC 来调节</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/1115674-6f67652a5b79322e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="对象图"></p>
<p>常见的使用解决方案:</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1115674-44d722eecf63d855.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="解决方案"></p>
<hr>
<h3 id="四-创建CoreDataStack"><a href="#四-创建CoreDataStack" class="headerlink" title="四. 创建CoreDataStack"></a>四. 创建CoreDataStack</h3><p>根据 CoreDataStack 示意图,将关系以代码的形式组织起来 !<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">// 实例化数据模型 </div><div class="line">NSURL *modelURL = [[NSBundle mainBundle] URLForResource:modelNamewithExtension:@&quot;momd&quot;];</div><div class="line">NSManagedObjectModel *model = [[NSManagedObjectModel alloc]initWithContentsOfURL:modelURL];</div><div class="line"></div><div class="line">// 实例化持久化储存</div><div class="line"> NSPersistentStoreCoordinator *psc = [[NSPersistentStoreCoordinator alloc] initWithManagedObjectModel:model];</div><div class="line"></div><div class="line">NSURL *dbURL = [[[NSFileManager defaultManager]URLsForDirectory:NSDocumentDirectory inDomains:NSUserDomainMask]lastObject];</div><div class="line"></div><div class="line">dbURL = [dbURL URLByAppendingPathComponent:dbName];[psc addPersistentStoreWithType:NSSQLiteStoreType configuration:nil</div><div class="line">URL:dbURL options:nil error:NULL];</div><div class="line"></div><div class="line">//  实例化上下文</div><div class="line">_managedObjectContext = [[NSManagedObjectContext alloc]initWithConcurrencyType:NSMainQueueConcurrencyType];</div><div class="line"></div><div class="line">[_managedObjectContext setPersistentStoreCoordinator:psc];</div></pre></td></tr></table></figure></p>
<hr>
<h3 id="一些提示"><a href="#一些提示" class="headerlink" title="[ 一些提示 ]"></a>[ 一些提示 ]</h3><blockquote>
<p>use scalar properties for primitive data type</p>
</blockquote>
<p>在 iOS5 和 OS X10.7 之前,scalar 不能自动生成,程序员必须自己添加 setter 和 getter 的实现</p>
<blockquote>
<p>@dynamic</p>
</blockquote>
<p>在 Objective-C 中,如果将某个属性实现为@dynamic,意味着告诉编译器不会在编译时确定这个属性的行为实现,因此不需要在编译期间对这个属性的 getter、setter 做检查.</p>
<hr>
<h3 id="五-CoreData-常见操作"><a href="#五-CoreData-常见操作" class="headerlink" title="五. CoreData 常见操作"></a>五. CoreData 常见操作</h3><h4 id="5-1-新增记录"><a href="#5-1-新增记录" class="headerlink" title="5.1 新增记录:"></a>5.1 新增记录:</h4><p>使用 NSEntityDescription 来创建对象,赋值后使用相应的 context 保存即可</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1115674-f7f81e014bd2e3d1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="新增"></p>
<h4 id="5-2-删除记录"><a href="#5-2-删除记录" class="headerlink" title="5.2 删除记录:"></a>5.2 删除记录:</h4><p>使用 context 的 deleteObject:删除被管理的模型对象后保存即可</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1115674-45d75517f3ba3970.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="删除记录"></p>
<h4 id="5-3-修改记录"><a href="#5-3-修改记录" class="headerlink" title="5.3 修改记录:"></a>5.3 修改记录:</h4><p>直接修改模型对象保存即可</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1115674-7f84be1adcaa5ddd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="修改记录"></p>
<h4 id="5-4-查询记录"><a href="#5-4-查询记录" class="headerlink" title="5.4 查询记录"></a>5.4 查询记录</h4><p>对使用 CoreData 进行存储的数据进行一定条件的查询后取出来使用</p>
<h5 id="5-4-1-谓词-is-—NSPredicate"><a href="#5-4-1-谓词-is-—NSPredicate" class="headerlink" title="5.4.1 谓词(is)—NSPredicate"></a>5.4.1 谓词(is)—NSPredicate</h5><p>作用:判断条件表达式的求值返回真或假的过程</p>
<p>使用步骤:</p>
<ul>
<li>定义 NSPredicate 对象并指定条件</li>
<li>调用谓词的 evaluateWithObject 方法判断指定条件是否满足示例:<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">NSPredicate *predicate = [NSPredicate predicateWithFormat:@&quot;self CONTAINS &apos;1&apos;&quot;];</div><div class="line">NSString *text = @&quot;1234&quot;;</div><div class="line">NSLog(@&quot;%d&quot;, [predicate evaluateWithObject:text]);</div></pre></td></tr></table></figure>
</li>
</ul>
<p>案例:</p>
<ol>
<li>创建 Person 的对象数组</li>
<li>查询判断姓名和年龄的过滤方法</li>
</ol>
<ul>
<li>传统方法</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">NSMutableArray *result = [NSMutableArray arrayWithCapacity:personList.count];</div><div class="line"></div><div class="line">for (NSInteger i = 0; i &lt; personList.count; i++)</div><div class="line"> &#123;</div><div class="line">    Person *person = personList[i];</div><div class="line">//  用户年龄小于5同时用户姓名中包含&quot;1&quot;字符串</div><div class="line">    if (person.age &lt; 5 &amp;&amp; NSNotFound != [person.name rangeOfString:@&quot;1&quot;].location)</div><div class="line">       &#123;</div><div class="line">           [result addObject:person];</div><div class="line">       &#125;</div><div class="line">  &#125;</div><div class="line">return result;</div></pre></td></tr></table></figure>
<ul>
<li>谓词方法</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">NSPredicate *predicate = [NSPredicate predicateWithFormat:@&quot;name CONTAINS &apos;1&apos; &amp;&amp; %K BETWEEN &#123;%d, %d&#125;&quot;,@&quot;age&quot;, 5, 15];</div><div class="line"></div><div class="line">NSArray *result = [personList filteredArrayUsingPredicate:predicate];</div></pre></td></tr></table></figure>
<h4 id="谓词的条件指令"><a href="#谓词的条件指令" class="headerlink" title="谓词的条件指令"></a>谓词的条件指令</h4><ol>
<li><p><code>&gt;  &lt;  ==  &gt;=  &lt;=  !=</code><br>例如:<br><code>@&quot;number &gt;= 99&quot;</code></p>
</li>
<li><p>范围运算符<code>IN  BETWEEN</code><br>例如:<br><code>@&quot;number BETWEEN {1,5}&quot;</code><br><code>@&quot;address IN {&#39;shanghai&#39;,&#39;nanjing&#39;}&quot;</code></p>
</li>
<li><p>字符串本身<code>:SELF</code><br>例如:<br><code>@&quot;SELF == &#39;APPLE&#39;&quot;</code></p>
</li>
<li><p>字符串相关: <code>BEGINSWITH ENDSWITH CONTAINS</code></p>
<p>例如:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">@&quot;name CONTAIN[cd] &apos;ang&apos;&quot; //包含某个字符串</div><div class="line">@&quot;name BEGINSWITH[c] &apos;sh&apos;&quot; //以某个字符串开头</div><div class="line">@&quot;name ENDSWITH[d] &apos;ang&apos;&quot; //以某个字符串结尾</div></pre></td></tr></table></figure>
</li>
<li><p>通配符:<code>LIKE</code><br>例如:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">@&quot;name LIKE[cd] &apos;*er*&apos;&quot; //* 代表通配符,Like 代表接受 [cd].</div><div class="line">@&quot;name LIKE[cd] &apos;???er*&apos;&quot;</div><div class="line"></div><div class="line"> 注:  星号&quot;*&quot; : 代表0或多个字符</div><div class="line">        问号&quot;?&quot; : 代表一个字符</div></pre></td></tr></table></figure>
</li>
<li><p>正则表达式:MATCHES<br>例如:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">NSString *regex = @&quot;^A.+e$&quot;; //以A开头, e结尾</div><div class="line">@&quot;name MATCHES %@&quot;,regex</div><div class="line">注:[c]不区分大小写,[d]不区分发音符号即没有重音符号,[cd]既不区分大小写,也不区分发音符号.</div></pre></td></tr></table></figure>
</li>
<li><p>合计操作<br>ANY SOME: 指定下列表达式中的任意元素<br>例如 <code>ANY children.age &lt; 18</code><br>ALL: 指定下列表达式中的所有元素<br>例如 <code>ALL children.age &lt; 18</code><br>NONE: 指定下列表达式中没有的元素<br>例如 <code>NONE children.age &lt; 18</code><br>在逻辑上等于NOT(ANY …)<br>IN:等于 SQL的<code>IN</code>操作,左边的表达必须出现在与右边指定的集合中<br>例如:<code>name IN { &#39;Ben&#39;,&#39;Melissa&#39;, &#39;Nick&#39; }</code></p>
</li>
</ol>
<h4 id="提示"><a href="#提示" class="headerlink" title="提示 :"></a>提示 :</h4><ol>
<li>谓词中的匹配指令关键字通常使用大写字母</li>
<li>谓词中可以使用格式字符串</li>
<li>如果通过对象的<code>key path</code> 指定匹配条件,需要使用 %K</li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[JMEmoticonDemo--自定义表情键盘]]></title>
      <url>http://jimmypeng.cn/2015/12/30/JMEmoticonDemo/</url>
      <content type="html"><![CDATA[<h1 id="JMEmoticonDemo"><a href="#JMEmoticonDemo" class="headerlink" title="JMEmoticonDemo"></a>JMEmoticonDemo</h1><h5 id="JMEmoticonDemo-是本人-Jimmy-使用Swift语言自定义的一个表情键盘。-基于新浪的表情包来实现表情在文本框的显示，实现表情的输入，可方便的整合入app-简单易用。"><a href="#JMEmoticonDemo-是本人-Jimmy-使用Swift语言自定义的一个表情键盘。-基于新浪的表情包来实现表情在文本框的显示，实现表情的输入，可方便的整合入app-简单易用。" class="headerlink" title="JMEmoticonDemo 是本人 Jimmy 使用Swift语言自定义的一个表情键盘。 基于新浪的表情包来实现表情在文本框的显示，实现表情的输入，可方便的整合入app , 简单易用。"></a>JMEmoticonDemo 是本人 Jimmy 使用Swift语言自定义的一个表情键盘。 基于新浪的表情包来实现表情在文本框的显示，实现表情的输入，可方便的整合入app , 简单易用。</h5><hr>
<h5 id="Github地址"><a href="#Github地址" class="headerlink" title="Github地址:"></a>Github地址:</h5><p><a href="https://github.com/JimmyPeng4iOS/JMEmoticon" target="_blank" rel="external">https://github.com/JimmyPeng4iOS/JMEmoticon</a></p>
<h2 id=""><a href="#" class="headerlink" title=""></a><a id="more"></a></h2><h5 id="可获取最近使用的表情"><a href="#可获取最近使用的表情" class="headerlink" title="可获取最近使用的表情"></a>可获取最近使用的表情</h5><p>按使用频率排序:</p>
<p><img src="http://7xpbws.com1.z0.glb.clouddn.com/blogemo1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="最近"></p>
<h4 id="另外三个表情包"><a href="#另外三个表情包" class="headerlink" title="另外三个表情包"></a>另外三个表情包</h4><ul>
<li>默认</li>
</ul>
<p><img src="http://7xpbws.com1.z0.glb.clouddn.com/blogemo2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="默认"></p>
<ul>
<li>Emoji</li>
</ul>
<p><img src="http://7xpbws.com1.z0.glb.clouddn.com/blogemo3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Emoji"></p>
<ul>
<li>浪小花</li>
</ul>
<h2 id="-1"><a href="#-1" class="headerlink" title=""></a><img src="http://7xpbws.com1.z0.glb.clouddn.com/blogemo4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="浪小花"></h2><h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法:"></a>使用方法:</h3><ul>
<li><p>自定义表请键盘的控制器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">private lazy var emoticonVC: EmoticonViewController = EmoticonViewController(textView: self.textView)</div></pre></td></tr></table></figure>
</li>
<li><p>将自定义键盘的控制器管理起来</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">addChildViewController(emoticonVC)</div><div class="line"></div><div class="line">textView.inputView = emoticonVC.view</div><div class="line">// 弹出键盘</div><div class="line">textView.becomeFirstResponder()</div></pre></td></tr></table></figure>
<p>当然了,如果表情键盘只是你的键盘的一部分, 还需要各位添加代码来实现 ⊙▽⊙</p>
</li>
</ul>
<hr>
<h5 id="最后-再来一遍github地址-๑•̀ㅂ•́-و✧"><a href="#最后-再来一遍github地址-๑•̀ㅂ•́-و✧" class="headerlink" title="最后 再来一遍github地址 (๑•̀ㅂ•́)و✧"></a>最后 再来一遍github地址 (๑•̀ㅂ•́)و✧</h5><p><a href="https://github.com/JimmyPeng4iOS/JMEmoticon" target="_blank" rel="external">https://github.com/JimmyPeng4iOS/JMEmoticon</a></p>
<hr>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[JMWaterFlow -- 快速布局瀑布流]]></title>
      <url>http://jimmypeng.cn/2015/12/30/JMWaterFlow/</url>
      <content type="html"><![CDATA[<h1 id="JMWaterFlow"><a href="#JMWaterFlow" class="headerlink" title="JMWaterFlow"></a>JMWaterFlow</h1><h5 id="JMWaterFlow-是本人-Jimmy-使用Swift语言对常见的-瀑布流-布局做的封装。-它使用UICollectionView来布局瀑布流，通过自定义layout布局来实现，简单易用。"><a href="#JMWaterFlow-是本人-Jimmy-使用Swift语言对常见的-瀑布流-布局做的封装。-它使用UICollectionView来布局瀑布流，通过自定义layout布局来实现，简单易用。" class="headerlink" title="JMWaterFlow 是本人 Jimmy 使用Swift语言对常见的 瀑布流 布局做的封装。 它使用UICollectionView来布局瀑布流，通过自定义layout布局来实现，简单易用。"></a>JMWaterFlow 是本人 Jimmy 使用Swift语言对常见的 <em>瀑布流</em> 布局做的封装。 它使用UICollectionView来布局瀑布流，通过自定义layout布局来实现，简单易用。</h5><hr>
<h5 id="Github地址"><a href="#Github地址" class="headerlink" title="Github地址:"></a>Github地址:</h5><p><a href="https://github.com/JimmyPeng4iOS/JMWaterFlow" target="_blank" rel="external">https://github.com/JimmyPeng4iOS/JMWaterFlow</a></p>
<h2 id=""><a href="#" class="headerlink" title=""></a><a id="more"></a></h2><ul>
<li>可自定义布局参数:<br><img src="http://upload-images.jianshu.io/upload_images/1115674-641c59c78a8bbb6d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="JMWaterFlow.png"></li>
</ul>
<h4 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h4><ul>
<li><p>构造方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"> let layout = WaterFlowViewLayout()</div><div class="line">//构造方法</div><div class="line">init()</div><div class="line">&#123;</div><div class="line">    super.init(collectionViewLayout: layout)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>初始化</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">let Margin:CGFloat = 8;</div><div class="line"></div><div class="line">/// 瀑布流四周的间距</div><div class="line">layout.sectionInsert = UIEdgeInsets(top: Margin, left: Margin, bottom: Margin, right: Margin)</div><div class="line"></div><div class="line">/// 瀑布流列数</div><div class="line">layout.column = 5</div><div class="line"></div><div class="line">/// 列间距</div><div class="line">layout.columnMargin = Margin</div><div class="line"></div><div class="line">/// 行间距</div><div class="line">layout.rowMargin = Margin</div><div class="line"></div><div class="line">// 设置代理</div><div class="line">layout.delegate = self</div></pre></td></tr></table></figure>
</li>
<li><p>实现代理方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">//MARK: 代理方法</div><div class="line">    /// 返回每个cell的高度,需要heightForWidth等比例缩放后的</div><div class="line">    func waterFlowViewLayout(waterFlowViewLayout: WaterFlowViewLayout, heightForWidth: CGFloat, atIndexPath: NSIndexPath) -&gt; CGFloat</div><div class="line">    &#123;</div><div class="line">        return CGFloat(100 + arc4random_uniform(50))//测试使用随机值</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    ///返回cell的数量</div><div class="line">    override func collectionView(collectionView: UICollectionView, numberOfItemsInSection section: Int) -&gt; Int</div><div class="line">    &#123;</div><div class="line">        return 500//测试</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    //返回cell</div><div class="line">    override func collectionView(collectionView: UICollectionView, cellForItemAtIndexPath indexPath: NSIndexPath) -&gt; UICollectionViewCell</div><div class="line">    &#123;</div><div class="line">        let cell = collectionView.dequeueReusableCellWithReuseIdentifier(ReuseIdentifier, forIndexPath: indexPath)</div><div class="line">        cell.backgroundColor = UIColor.randomColor()//测试使用随机色</div><div class="line">        return cell</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h5 id="最后-再来一遍github地址-๑•̀ㅂ•́-و✧"><a href="#最后-再来一遍github地址-๑•̀ㅂ•́-و✧" class="headerlink" title="最后 再来一遍github地址 (๑•̀ㅂ•́)و✧"></a>最后 再来一遍github地址 (๑•̀ㅂ•́)و✧</h5><p><a href="https://github.com/JimmyPeng4iOS/JMWaterFlow" target="_blank" rel="external">https://github.com/JimmyPeng4iOS/JMWaterFlow</a></p>
<hr>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[JMpickerView -- 控制器切换框架]]></title>
      <url>http://jimmypeng.cn/2015/12/28/JMpickerView/</url>
      <content type="html"><![CDATA[<h1 id="JMpickerView"><a href="#JMpickerView" class="headerlink" title="JMpickerView"></a>JMpickerView</h1><h5 id="JMpickerView-是本人-Jimmy-使用Objective-C语言对子控制器间平滑切换封装的一个框架。-基于UIViewController的容器属性，通过添加子容器-可平滑高效的切换界面-同时保证只存在一个控制器-其他控制器在移出控制器时进行了缓存和销毁-简单易用-效率高。"><a href="#JMpickerView-是本人-Jimmy-使用Objective-C语言对子控制器间平滑切换封装的一个框架。-基于UIViewController的容器属性，通过添加子容器-可平滑高效的切换界面-同时保证只存在一个控制器-其他控制器在移出控制器时进行了缓存和销毁-简单易用-效率高。" class="headerlink" title="JMpickerView 是本人 Jimmy 使用Objective-C语言对子控制器间平滑切换封装的一个框架。 基于UIViewController的容器属性，通过添加子容器,可平滑高效的切换界面,同时保证只存在一个控制器,其他控制器在移出控制器时进行了缓存和销毁, 简单易用,效率高。"></a>JMpickerView 是本人 Jimmy 使用<code>Objective-C</code>语言对子控制器间平滑切换封装的一个框架。 基于<code>UIViewController</code>的容器属性，通过添加子容器,可平滑高效的切换界面,同时保证只存在一个控制器,其他控制器在移出控制器时进行了缓存和销毁, 简单易用,效率高。</h5><hr>
<h5 id="Github地址"><a href="#Github地址" class="headerlink" title="Github地址:"></a>Github地址:</h5><p><a href="https://github.com/JimmyPeng4iOS/JMPickerView" target="_blank" rel="external">https://github.com/JimmyPeng4iOS/JMPickerView</a></p>
<h2 id=""><a href="#" class="headerlink" title=""></a><a id="more"></a></h2><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p><img src="http://7xpbws.com1.z0.glb.clouddn.com/blogpicker2.gif?imageMogr2/auto-orient/strip" alt="示例"></p>
<h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法:"></a>使用方法:</h3><ul>
<li>懒加载选择bar和主View</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">//顶部 选择bar</div><div class="line">- (JMtopSeleteView *)topView</div><div class="line">&#123;</div><div class="line">    if (_topView == nil)</div><div class="line">    &#123;</div><div class="line">        //指定按钮的数目(不建议超过6个), 标题数组 , 标题颜色,  bar的颜色</div><div class="line">               _topView = [JMtopSeleteView topViewWithNum:4</div><div class="line">                                           andTitle:@[@&quot;gray&quot;,@&quot;red&quot;,@&quot;yellow&quot;,@&quot;blue&quot;]</div><div class="line">                                           titleColor:[UIColor orangeColor]</div><div class="line">                                           barColor:[UIColor whiteColor]];</div><div class="line">        //可自定义frame</div><div class="line">        _topView.frame = CGRectMake(0, 64,ScreenWidth, 44);</div><div class="line">    &#125;</div><div class="line">    return _topView;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//主View</div><div class="line">- (JMPickerView *)pickerView</div><div class="line">&#123;</div><div class="line">    if (_pickerView == nil)</div><div class="line">    &#123;     //指定父容器, 一般为self</div><div class="line">        _pickerView = [JMPickerView pickerViewWithBaseViewController:self];</div><div class="line">        //View的frame</div><div class="line">        _pickerView.frame = CGRectMake(0,108, ScreenWidth, ScreenHeight-108);</div><div class="line">        //替换view</div><div class="line">        self.view = _pickerView;</div><div class="line">        //添加topBar</div><div class="line">        [self.view addSubview:self.topView];</div><div class="line">    &#125;</div><div class="line">    return _pickerView;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>初始化</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">//遵守&lt;JMtopSeleteViewDelegate&gt;代理</div><div class="line">  self.topView.delegate = self;</div><div class="line">//定义一开始显示的页面</div><div class="line">  self.pickerView.seletedIndex = 0;</div></pre></td></tr></table></figure>
<ul>
<li>实现代理方法</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">- (UIViewController *)JMtopSeleteView:(JMtopSeleteView *)sender controllerAt:(NSInteger)index</div><div class="line">&#123;</div><div class="line">    switch (index)</div><div class="line">    &#123;</div><div class="line">        case 0:</div><div class="line">            return [[GrayViewController alloc] init];</div><div class="line">        case 1:</div><div class="line">            return [[RedViewController  alloc] init];</div><div class="line">        case 2:</div><div class="line">            return [[YellowViewController alloc] init];</div><div class="line">        default:</div><div class="line">            return [[BlueViewController alloc] init];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<h5 id="最后-再来一遍github地址-๑•̀ㅂ•́-و✧"><a href="#最后-再来一遍github地址-๑•̀ㅂ•́-و✧" class="headerlink" title="最后 再来一遍github地址 (๑•̀ㅂ•́)و✧"></a>最后 再来一遍github地址 (๑•̀ㅂ•́)و✧</h5><p><a href="https://github.com/JimmyPeng4iOS/JMPickerView" target="_blank" rel="external">https://github.com/JimmyPeng4iOS/JMPickerView</a></p>
<hr>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[JMCarouselView -- 图片轮播器]]></title>
      <url>http://jimmypeng.cn/2015/12/19/JMCarouselView/</url>
      <content type="html"><![CDATA[<h5 id="JMCarouselView-是本人-Jimmy-使用Swift语言封装的图片轮播器。-基于UIScrollView-UICollectionView-用两种思路做了整合-可实现无间隙循环播放，可方便的整合入app-支持本地图片和网络图片-依赖SDWebImage-第三方库-简单易用。"><a href="#JMCarouselView-是本人-Jimmy-使用Swift语言封装的图片轮播器。-基于UIScrollView-UICollectionView-用两种思路做了整合-可实现无间隙循环播放，可方便的整合入app-支持本地图片和网络图片-依赖SDWebImage-第三方库-简单易用。" class="headerlink" title="JMCarouselView 是本人 Jimmy 使用Swift语言封装的图片轮播器。 基于UIScrollView/UICollectionView 用两种思路做了整合, 可实现无间隙循环播放，可方便的整合入app , 支持本地图片和网络图片(依赖SDWebImage 第三方库), 简单易用。"></a>JMCarouselView 是本人 Jimmy 使用Swift语言封装的图片轮播器。 基于UIScrollView/UICollectionView 用两种思路做了整合, 可实现无间隙循环播放，可方便的整合入app , 支持本地图片和网络图片(依赖SDWebImage 第三方库), 简单易用。</h5><hr>
<h5 id="Github地址"><a href="#Github地址" class="headerlink" title="Github地址:"></a>Github地址:</h5><p><a href="https://github.com/JimmyPeng4iOS/JMCarouselView" target="_blank" rel="external">https://github.com/JimmyPeng4iOS/JMCarouselView</a></p>
<h2 id=""><a href="#" class="headerlink" title=""></a><a id="more"></a></h2><h5 id="无间隙循环展示"><a href="#无间隙循环展示" class="headerlink" title="无间隙循环展示"></a>无间隙循环展示</h5><p><img src="http://7xpbws.com1.z0.glb.clouddn.com/picker.gif?imageMogr2/auto-orient/strip" alt="JMCarouselView.gif"></p>
<h1 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法:"></a>使用方法:</h1><ul>
<li>主要有两种思路 </li>
</ul>
<h2 id="ScrollView"><a href="#ScrollView" class="headerlink" title="ScrollView"></a>ScrollView</h2><ul>
<li><p>初始化方法1 – 网络加载</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"> /**</div><div class="line">初始化方法1,传入图片URL数组,以及pageControl的当前page点的颜色,特别注意需要SDWebImage框架支持</div><div class="line">    </div><div class="line">- parameter frame:          frame</div><div class="line">- parameter imgURLArray:    图片URL数组</div><div class="line">- parameter pagePointColor: pageControl的当前page点的颜色</div><div class="line">- parameter stepTime:       广告每一页停留时间</div><div class="line">    </div><div class="line">- returns: ScrollView图片轮播器</div><div class="line">*/</div><div class="line"></div><div class="line">    headerView = JMCarouselScrollView(</div><div class="line">                                    frame: CGRect(x: 0, y: 0, width:UIScreen.mainScreen().bounds.width, height: 220),</div><div class="line">                                    imageURLArray: urlStringArr(),</div><div class="line">                                    pagePointColor: UIColor.whiteColor(),</div><div class="line">                                    stepTime: 2.0)</div></pre></td></tr></table></figure>
</li>
<li><p>初始化方法2 – 本地加载</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">初始化方法2,传入图片数组,以及pageControl的当前page点的颜色,无需依赖第三方库</div><div class="line"></div><div class="line">- parameter frame:          frame</div><div class="line">- parameter imgArray:       图片数组</div><div class="line">- parameter pagePointColor: pageControl的当前page点的颜色</div><div class="line">- parameter stepTime:       广告每一页停留时间</div><div class="line"></div><div class="line">- returns: ScrollView图片轮播器</div><div class="line">*/</div><div class="line"></div><div class="line">headerView = JMCarouselScrollView(</div><div class="line">                                frame: CGRect(x: 0, y: 0, width:UIScreen.mainScreen().bounds.width, height: 220),</div><div class="line">                                imgArray: imgArray(),</div><div class="line">                                pagePointColor: UIColor.whiteColor(),</div><div class="line">                                stepTime: 2.0)</div></pre></td></tr></table></figure>
</li>
</ul>
<p>ScrollView是采用前后添加一张图片,然后到达多出来的两张图片瞬间跳转(肉眼观察不到)的方式来实现无限轮播</p>
<h2 id="CollectionView"><a href="#CollectionView" class="headerlink" title="CollectionView"></a>CollectionView</h2><ul>
<li><p>初始化方法1 – 网络加载</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"> /**</div><div class="line">初始化方法1,传入图片URL数组,以及pageControl的当前page点的颜色,特别注意需要SDWebImage框架支持</div><div class="line">    </div><div class="line">- parameter frame:          frame</div><div class="line">- parameter imgURLArray:    图片URL数组</div><div class="line">- parameter pagePointColor: pageControl的当前page点的颜色</div><div class="line">- parameter stepTime:       广告每一页停留时间</div><div class="line">    </div><div class="line">- returns: ScrollView图片轮播器</div><div class="line">*/</div><div class="line"></div><div class="line">    headerView = JMCarouselCollection(</div><div class="line">                                    frame: CGRect(x: 0, y: 0, width:UIScreen.mainScreen().bounds.width, height: 220),</div><div class="line">                                    imageURLArray: urlStringArr(),</div><div class="line">                                    pagePointColor: UIColor.whiteColor(),</div><div class="line">                                    stepTime: 2.0)</div></pre></td></tr></table></figure>
</li>
<li><p>初始化方法2 – 本地加载</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">初始化方法2,传入图片数组,以及pageControl的当前page点的颜色,无需依赖第三方库</div><div class="line"></div><div class="line">- parameter frame:          frame</div><div class="line">- parameter imgArray:       图片数组</div><div class="line">- parameter pagePointColor: pageControl的当前page点的颜色</div><div class="line">- parameter stepTime:       广告每一页停留时间</div><div class="line"></div><div class="line">- returns: ScrollView图片轮播器</div><div class="line">*/</div><div class="line"></div><div class="line">headerView = JMCarouselCollection(</div><div class="line">                                frame: CGRect(x: 0, y: 0, width:UIScreen.mainScreen().bounds.width, height: 220),</div><div class="line">                                imgArray: imgArray(),</div><div class="line">                                pagePointColor: UIColor.whiteColor(),</div><div class="line">                                stepTime: 2.0)</div></pre></td></tr></table></figure>
</li>
</ul>
<p>CollectionView是添加大量的组,每一组的items就是需要展示的图片,来实现伪无限轮播,由于SDWebImage自带缓存功能, 使用本地的方式也会去下载,该方法不会浪费用户流量</p>
<h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项:"></a>注意事项:</h1><ol>
<li>需要使用第一种初始化方式传入URL的时候, 需要依赖第三方库  SDWebImage!! ⊙▽⊙</li>
<li>通过替换<code>Assets.xcassets</code>资源夹内的<code>holder.jpg</code>可更改placeholderImage(建议使用同名,要更换名字可到源文件下更改)</li>
<li>需要定义一个属性强引用轮播器,以便于释放内存<br>eg.</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var headerView: JMCarouselCollection?</div><div class="line"></div><div class="line">headerView =JMCarouselCollection(xxxxxxxx) </div><div class="line"></div><div class="line">tableView.tableHeaderView = headerView</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">//MARK:释放</div><div class="line">override func viewWillDisappear(animated: Bool)</div><div class="line">&#123;</div><div class="line">    headerView?.stopTimer()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<h5 id="最后-再来一遍github地址-๑•̀ㅂ•́-و✧"><a href="#最后-再来一遍github地址-๑•̀ㅂ•́-و✧" class="headerlink" title="最后 再来一遍github地址 (๑•̀ㅂ•́)و✧"></a>最后 再来一遍github地址 (๑•̀ㅂ•́)و✧</h5><p><a href="https://github.com/JimmyPeng4iOS/JMCarouselView" target="_blank" rel="external">https://github.com/JimmyPeng4iOS/JMCarouselView</a></p>
<hr>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[SQLite数据库框架--FMDB]]></title>
      <url>http://jimmypeng.cn/2015/11/27/fmdb/</url>
      <content type="html"><![CDATA[<h3 id="FMDB概述"><a href="#FMDB概述" class="headerlink" title="FMDB概述"></a>FMDB概述</h3><hr>
<h4 id="什么是FMDB"><a href="#什么是FMDB" class="headerlink" title="什么是FMDB"></a>什么是FMDB</h4><ul>
<li>FMDB是iOS平台的SQLite数据库框架</li>
<li>FMDB以OC的方式封装了SQLite的C语言API</li>
</ul>
<h4 id="FMDB的优点"><a href="#FMDB的优点" class="headerlink" title="FMDB的优点"></a>FMDB的优点</h4><ul>
<li>使用起来更加面向对象，省去了很多麻烦、冗余的C语言代码</li>
<li>对比苹果自带的Core Data框架，更加轻量级和灵活</li>
<li>提供了多线程安全的数据库操作方法，有效地防止数据混乱</li>
</ul>
<h4 id="FMDB的github地址"><a href="#FMDB的github地址" class="headerlink" title="FMDB的github地址"></a>FMDB的github地址</h4><ul>
<li><a href="https://github.com/ccgus/fmdb" target="_blank" rel="external">https://github.com/ccgus/fmdb</a></li>
</ul>
<a id="more"></a>
<h1 id="FMDB基本使用"><a href="#FMDB基本使用" class="headerlink" title="FMDB基本使用"></a>FMDB基本使用</h1><hr>
<h3 id="FMDB有三个核心类"><a href="#FMDB有三个核心类" class="headerlink" title="FMDB有三个核心类"></a>FMDB有三个核心类</h3><p>  <strong>FMDatabase</strong></p>
<ul>
<li>一个FMDatabase对象就代表一个单独的SQLite数据库 用来执行SQL语句</li>
</ul>
<p><strong> FMResultSet</strong></p>
<ul>
<li>使用FMDatabase执行查询后的结果集</li>
</ul>
<p><strong> FMDatabaseQueue</strong></p>
<ul>
<li>用于在多线程中执行多个查询或更新，它是线程安全的</li>
</ul>
<h2 id="FMDB打开数据库"><a href="#FMDB打开数据库" class="headerlink" title="FMDB打开数据库"></a>FMDB打开数据库</h2><p><strong>通过指定SQLite数据库文件路径来创建FMDatabase对象</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">FMDatabase *db = [FMDatabase databaseWithPath:path];</div><div class="line">if (![db open]) </div><div class="line">&#123;</div><div class="line">    NSLog(@&quot;数据库打开失败！&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>文件路径(path)有三种情况:</strong></p>
<ul>
<li>具体文件路径<ul>
<li>如果不存在会自动创建</li>
</ul>
</li>
<li>空字符串@””<ul>
<li>会在临时目录创建一个空的数据库</li>
<li>当FMDatabase连接关闭时，数据库文件也被删除</li>
</ul>
</li>
<li>nil<ul>
<li>会创建一个内存中临时数据库</li>
<li>当FMDatabase连接关闭时，数据库会被销毁</li>
</ul>
</li>
</ul>
<h2 id="执行更新"><a href="#执行更新" class="headerlink" title="执行更新"></a>执行更新</h2><p><strong>在FMDB中，除查询以外的所有操作，都称为“更新”create、drop、insert、update、delete等</strong></p>
<ul>
<li><p>使用executeUpdate:方法执行更新</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">- (BOOL)executeUpdate:(NSString*)sql, ...</div><div class="line">- (BOOL)executeUpdateWithFormat:(NSString*)format, ...</div><div class="line">- (BOOL)executeUpdate:(NSString*)sql withArgumentsInArray:(NSArray *)arguments</div></pre></td></tr></table></figure>
</li>
<li><p>示例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[db executeUpdate:@&quot;UPDATE t_student SET age = ? WHERE name = ?;&quot;, @20, @&quot;Jack&quot;]</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="执行查询"><a href="#执行查询" class="headerlink" title="执行查询"></a>执行查询</h2><p><strong>查询方法</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">- (FMResultSet *)executeQuery:(NSString*)sql, ...</div><div class="line">- (FMResultSet *)executeQueryWithFormat:(NSString*)format, ...</div><div class="line">- (FMResultSet *)executeQuery:(NSString *)sql withArgumentsInArray:(NSArray *)arguments</div></pre></td></tr></table></figure></p>
<ul>
<li>示例<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">// 查询数据</div><div class="line">FMResultSet *rs = [db executeQuery:@&quot;SELECT * FROM t_student&quot;];</div><div class="line"></div><div class="line">// 遍历结果集</div><div class="line">while ([rs next]) &#123;</div><div class="line">    NSString *name = [rs stringForColumn:@&quot;name&quot;];</div><div class="line">    int age = [rs intForColumn:@&quot;age&quot;];</div><div class="line">    double score = [rs doubleForColumn:@&quot;score&quot;];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="FMDatabaseQueue"><a href="#FMDatabaseQueue" class="headerlink" title="##FMDatabaseQueue"></a>##FMDatabaseQueue</h2><ul>
<li><p>FMDatabase这个类是线程不安全的，如果在多个线程中同时使用一个FMDatabase实例，会造成数据混乱等问题.</p>
</li>
<li><p>为了保证线程安全，FMDB提供方便快捷的FMDatabaseQueue类</p>
</li>
<li><p>FMDatabaseQueue的创建</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">FMDatabaseQueue *queue = [FMDatabaseQueue databaseQueueWithPath:path];</div></pre></td></tr></table></figure>
</li>
<li><p>简单使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">[queue inDatabase:^(FMDatabase *db) &#123;</div><div class="line">   [db executeUpdate:@&quot;INSERT INTO t_student(name) VALUES (?)&quot;, @&quot;Jack&quot;];</div><div class="line">   [db executeUpdate:@&quot;INSERT INTO t_student(name) VALUES (?)&quot;, @&quot;Rose&quot;];</div><div class="line">   [db executeUpdate:@&quot;INSERT INTO t_student(name) VALUES (?)&quot;, @&quot;Jim&quot;];</div><div class="line"></div><div class="line">   FMResultSet *rs = [db executeQuery:@&quot;select * from t_student&quot;];</div><div class="line">   while ([rs next]) &#123;</div><div class="line">   // …</div><div class="line">   &#125;</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
</li>
<li><p>使用事务</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">[queue inTransaction:^(FMDatabase *db, BOOL *rollback) &#123;</div><div class="line">  [db executeUpdate:@&quot;INSERT INTO t_student(name) VALUES (?)&quot;, @&quot;Jack&quot;];</div><div class="line">  [db executeUpdate:@&quot;INSERT INTO t_student(name) VALUES (?)&quot;, @&quot;Rose&quot;];</div><div class="line">  [db executeUpdate:@&quot;INSERT INTO t_student(name) VALUES (?)&quot;, @&quot;Jim&quot;];</div><div class="line"></div><div class="line">  FMResultSet *rs = [db executeQuery:@&quot;select * from t_student&quot;];</div><div class="line">  while ([rs next]) &#123;</div><div class="line">      // …</div><div class="line">  &#125;</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
</li>
<li><p>事务回滚</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rollback = YES;</div></pre></td></tr></table></figure></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Xcode7 真机测试出现 "The account 'Apple ID' has no team with ID 'team ID'的解决方案]]></title>
      <url>http://jimmypeng.cn/2015/10/28/Xcode7test/</url>
      <content type="html"><![CDATA[<h2 id="转载请注明出处-谢谢-～-o-～-Y"><a href="#转载请注明出处-谢谢-～-o-～-Y" class="headerlink" title="转载请注明出处, 谢谢! (～ o ～)Y"></a>转载请注明出处, 谢谢! (～ o ～)Y</h2><hr>
<h5 id="之前一段时间，周围挺多人出现了Xcode真机测试出现"><a href="#之前一段时间，周围挺多人出现了Xcode真机测试出现" class="headerlink" title="之前一段时间，周围挺多人出现了Xcode真机测试出现"></a>之前一段时间，周围挺多人出现了Xcode真机测试出现</h5><blockquote>
<p>“The account ‘Apple ID’ has no team with ID ‘team ID’ </p>
</blockquote>
<p>导致无法真机测试，如图：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1115674-5d43defb714681f4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="错误提示"></p>
<h3 id="找了很久没有找到解决方法，最后发现应该是苹果账号中心出现问题，最后发了邮件给苹果，官方就帮我解决了，步骤如下："><a href="#找了很久没有找到解决方法，最后发现应该是苹果账号中心出现问题，最后发了邮件给苹果，官方就帮我解决了，步骤如下：" class="headerlink" title="找了很久没有找到解决方法，最后发现应该是苹果账号中心出现问题，最后发了邮件给苹果，官方就帮我解决了，步骤如下："></a>找了很久没有找到解决方法，最后发现应该是苹果账号中心出现问题，最后发了邮件给苹果，官方就帮我解决了，步骤如下：</h3><h2 id=""><a href="#" class="headerlink" title=""></a><a id="more"></a></h2><ul>
<li><p>登陆苹果开发者官方支持<br><a href="https://developer.apple.com/cn/contact/" target="_blank" rel="external">https://developer.apple.com/cn/contact/</a></p>
</li>
<li><p>拖动到页面最下方，可以换成简体中文(英语专八可以忽略..)<br><img src="http://upload-images.jianshu.io/upload_images/1115674-8205557d8b150e32.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="简体中文"></p>
</li>
<li><p>回到顶部，选择 <em>Apple Developer Program Support</em><br><img src="http://upload-images.jianshu.io/upload_images/1115674-a4b918e85c5be7b4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="support"></p>
</li>
<li><p>这时候需要你登陆你的apple账号<br><img src="http://upload-images.jianshu.io/upload_images/1115674-fce487c70a9d4cb2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="登陆"></p>
<ul>
<li>这时候你会发现，你的账号会提示出现问题<br><img src="http://upload-images.jianshu.io/upload_images/1115674-0aa1ce8d28c1c8fb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="problem"></li>
</ul>
</li>
<li><p>点击contact us , 进行上面相同的操作, 然后填写问题描述<br><img src="http://upload-images.jianshu.io/upload_images/1115674-0622bc8f087d453f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="表格"></p>
<ul>
<li>然后苹果收到就会给你一个回复邮件<br><img src="http://upload-images.jianshu.io/upload_images/1115674-06ff12e3114d0ab6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="mail"></li>
</ul>
</li>
<li><p>po主等待一天之后, 收到苹果的解决回信<br><img src="http://upload-images.jianshu.io/upload_images/1115674-87e73090499ad210.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="解决"></p>
</li>
</ul>
<p>#这时候运行,发现还不可以正常使用,出现</p>
<blockquote>
<p>######The identity used to sign the executeble is no longer valid.<br>Please verify that your device’s clock is properly set, and that your signing certificate is not expired.(0xE8008018)</p>
</blockquote>
<p> 需要把旧的证书删除, 重新生成证书</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1115674-a1f19736ab67dcff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<ul>
<li>来到系统的钥匙串,可以看到旧的证书已过期<br><img src="http://upload-images.jianshu.io/upload_images/1115674-004cb276a1b902ce.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></li>
</ul>
<h2 id="点左边的三角形箭头-打开-选中两个一起删除-重要-不然无法删除"><a href="#点左边的三角形箭头-打开-选中两个一起删除-重要-不然无法删除" class="headerlink" title="点左边的三角形箭头, 打开,选中两个一起删除!!(重要, 不然无法删除)"></a>点左边的三角形箭头, 打开,选中两个一起删除!!(重要, 不然无法删除)</h2><p><img src="http://upload-images.jianshu.io/upload_images/1115674-cca1d6329337f4d6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="重要"></p>
<ul>
<li>然后来到Xcode偏好设置, 重新生成证书<br><img src="http://upload-images.jianshu.io/upload_images/1115674-9e283e7d093844c9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>双击<br><img src="http://upload-images.jianshu.io/upload_images/1115674-3c22e3058104f361.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>reset<br><img src="http://upload-images.jianshu.io/upload_images/1115674-093448940ba23dfc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></li>
</ul>
<p>之后运行就是Security状态, 这里可以参考我之前的文章, 在手机打开开发者验证<br><img src="http://upload-images.jianshu.io/upload_images/1115674-dcc4da67f13eeeeb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<hr>
<p>#地址:<a href="http://www.jianshu.com/p/4aab37a6bd86" target="_blank" rel="external"> Xcode 7免证书真机调试–by Jimmy</a></p>
<hr>
<p>##然后就可以正常使用了(๑•̀ㅂ•́)و✧.. 希望可以帮助到大家，还有！求赞ಥ_ಥ！</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Xcode 7免证书真机调试]]></title>
      <url>http://jimmypeng.cn/2015/09/18/xcode_7test/</url>
      <content type="html"><![CDATA[<h1 id="Xcode-7免证书真机调试"><a href="#Xcode-7免证书真机调试" class="headerlink" title="Xcode 7免证书真机调试"></a>Xcode 7免证书真机调试</h1><hr>
<h4 id="在Xcode-7中，苹果改变了自己在许可权限上的策略，此前Xcode只开放给注册开发者下载，但Xcode-7改变了这种惯有的做法，无需注册开发者账号，仅使用普通的Apple-ID就能下载和上手体验。此前开发者需每年支付99美元的费用成为注册开发者才能在iPhone和iPad真机上运行代码，苹果新的开发者计划则放宽要求，无需购买，只要你感兴趣同样可以在设备上测试app。"><a href="#在Xcode-7中，苹果改变了自己在许可权限上的策略，此前Xcode只开放给注册开发者下载，但Xcode-7改变了这种惯有的做法，无需注册开发者账号，仅使用普通的Apple-ID就能下载和上手体验。此前开发者需每年支付99美元的费用成为注册开发者才能在iPhone和iPad真机上运行代码，苹果新的开发者计划则放宽要求，无需购买，只要你感兴趣同样可以在设备上测试app。" class="headerlink" title="在Xcode 7中，苹果改变了自己在许可权限上的策略，此前Xcode只开放给注册开发者下载，但Xcode 7改变了这种惯有的做法，无需注册开发者账号，仅使用普通的Apple ID就能下载和上手体验。此前开发者需每年支付99美元的费用成为注册开发者才能在iPhone和iPad真机上运行代码，苹果新的开发者计划则放宽要求，无需购买，只要你感兴趣同样可以在设备上测试app。"></a>在Xcode 7中，苹果改变了自己在许可权限上的策略，此前Xcode只开放给注册开发者下载，但Xcode 7改变了这种惯有的做法，无需注册开发者账号，仅使用普通的Apple ID就能下载和上手体验。此前开发者需每年支付99美元的费用成为注册开发者才能在iPhone和iPad真机上运行代码，苹果新的开发者计划则放宽要求，无需购买，只要你感兴趣同样可以在设备上测试app。</h4><a id="more"></a>
<p> 　　如果你打算向App Store提交应用，那仍然需要付费。</p>
<p>　　使用方法：</p>
<p>　　1.新建一个普通的项目</p>
<p>　　2.进入xcode，菜单栏选择xcode –&gt; preferences （快捷键 command + ）</p>
<p><img src="http://7xpbws.com1.z0.glb.clouddn.com/blogxc1.jpg" alt=""></p>
<p>　　3.在Accounts选项卡添加自己的Apple ID。</p>
<p> 　　添加完成后你会看到这样的信息。</p>
<p><img src="http://7xpbws.com1.z0.glb.clouddn.com/blogxc2.jpg" alt=""></p>
<p> 　　可以看到下面显示了iOS和Mac的Free标记了，在这之前是没有这些标记的。</p>
<p>　　4.生成证书。</p>
<p> 　　点击View Details。会出现图一的样式。</p>
<p> 　　点中间的“+”号按钮，弹出菜单中选择iOS Development，然后稍等片刻（正常情况下），Xcode就会帮你生成好Dev模式需要的certificate了。<br><img src="http://7xpbws.com1.z0.glb.clouddn.com/blogxc3.jpg" alt=""></p>
<p><img src="http://7xpbws.com1.z0.glb.clouddn.com/blogxc4.jpg" alt=""></p>
<p> 　　5.在项目target的General页的Team中选中刚才Apple ID对应的项。</p>
<p><img src="http://7xpbws.com1.z0.glb.clouddn.com/blogxc5.jpg" alt=""></p>
<p> 　　6.添加Provisioning Profile。</p>
<p> 　　在刚才选择Team的下面弹出的Issue下面，点Fix。一切就都由Xcode搞定了。</p>
<p><img src="http://7xpbws.com1.z0.glb.clouddn.com/blogxc6.jpg" alt=""><br>　　7.运行。</p>
<p> 　　运行的时候这里可能会再手机上出现一个“不受信任的开发者”的提示。<br><img src="http://7xpbws.com1.z0.glb.clouddn.com/blogxc7.jpg" alt=""></p>
<p>　　“设置” –“通用” –“描述文件”(iOS9.2中为 描述文件与设备管理 )<br><img src="http://7xpbws.com1.z0.glb.clouddn.com/blogxc8.jpg" alt=""><br>　　“开发者账号”<br><img src="http://7xpbws.com1.z0.glb.clouddn.com/blogxc9.jpg" alt=""><br>　　“信任开发者账号”<br><img src="http://7xpbws.com1.z0.glb.clouddn.com/blogxc10.jpg" alt=""><br>　　“信任”</p>
<p>　　最后就能跑起来啦！！！</p>
]]></content>
    </entry>
    
  
  
</search>
